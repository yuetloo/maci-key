"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[344],{409:function(t,e,i){var n=i(3454);Object.defineProperty(e,"__esModule",{value:!0});var s=i(4736),r=i(2474),h=i(3671),o=i(3461),f=i(4763);function u(t){return t&&"object"===typeof t&&"default"in t?t:{default:t}}var a=u(s),l=u(r),p=u(h),c=u(o),m=u(f);const g=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];function d(t,e){return e&&10!=e?16==e?"0x"==t.slice(0,2)?BigInt(t):BigInt("0x"+t):void 0:BigInt(t)}const F=d;function b(t,e){return BigInt(t)<<BigInt(e)}function w(t,e){return BigInt(t)>>BigInt(e)}const y=b,L=w;var v=Object.freeze({__proto__:null,fromString:d,e:F,fromArray:function(t,e){let i=0n;e=BigInt(e);for(let n=0;n<t.length;n++)i=i*e+BigInt(t[n]);return i},bitLength:function(t){const e=t.toString(16);return 4*(e.length-1)+g[parseInt(e[0],16)]},isNegative:function(t){return BigInt(t)<0n},isZero:function(t){return!t},shiftLeft:b,shiftRight:w,shl:y,shr:L,isOdd:function(t){return 1n==(1n&BigInt(t))},naf:function(t){let e=BigInt(t);const i=[];for(;e;){if(1n&e){const t=2-Number(e%4n);i.push(t),e-=BigInt(t)}else i.push(0);e>>=1n}return i},bits:function(t){let e=BigInt(t);const i=[];for(;e;)1n&e?i.push(1):i.push(0),e>>=1n;return i},toNumber:function(t){if(t>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("Number too big");return Number(t)},toArray:function(t,e){const i=[];let n=BigInt(t);for(e=BigInt(e);n;)i.unshift(Number(n%e)),n/=e;return i},add:function(t,e){return BigInt(t)+BigInt(e)},sub:function(t,e){return BigInt(t)-BigInt(e)},neg:function(t){return-BigInt(t)},mul:function(t,e){return BigInt(t)*BigInt(e)},square:function(t){return BigInt(t)*BigInt(t)},pow:function(t,e){return BigInt(t)**BigInt(e)},exp:function(t,e){return BigInt(t)**BigInt(e)},abs:function(t){return BigInt(t)>=0?BigInt(t):-BigInt(t)},div:function(t,e){return BigInt(t)/BigInt(e)},mod:function(t,e){return BigInt(t)%BigInt(e)},eq:function(t,e){return BigInt(t)==BigInt(e)},neq:function(t,e){return BigInt(t)!=BigInt(e)},lt:function(t,e){return BigInt(t)<BigInt(e)},gt:function(t,e){return BigInt(t)>BigInt(e)},leq:function(t,e){return BigInt(t)<=BigInt(e)},geq:function(t,e){return BigInt(t)>=BigInt(e)},band:function(t,e){return BigInt(t)&BigInt(e)},bor:function(t,e){return BigInt(t)|BigInt(e)},bxor:function(t,e){return BigInt(t)^BigInt(e)},land:function(t,e){return BigInt(t)&&BigInt(e)},lor:function(t,e){return BigInt(t)||BigInt(e)},lnot:function(t){return!BigInt(t)}});function B(t,e){return"string"==typeof t&&"0x"==t.slice(0,2)?a.default(t.slice(2),16):a.default(t,e)}const E=B;function q(t,e){return a.default(t).shiftLeft(e)}function O(t,e){return a.default(t).shiftRight(e)}const _=q,A=O;var R=Object.freeze({__proto__:null,fromString:B,e:E,fromArray:function(t,e){return a.default.fromArray(t,e)},bitLength:function(t){return a.default(t).bitLength()},isNegative:function(t){return a.default(t).isNegative()},isZero:function(t){return a.default(t).isZero()},shiftLeft:q,shiftRight:O,shl:_,shr:A,isOdd:function(t){return a.default(t).isOdd()},naf:function(t){let e=a.default(t);const i=[];for(;e.gt(a.default.zero);){if(e.isOdd()){const t=2-e.mod(4).toJSNumber();i.push(t),e=e.minus(t)}else i.push(0);e=e.shiftRight(1)}return i},bits:function(t){let e=a.default(t);const i=[];for(;e.gt(a.default.zero);)e.isOdd()?i.push(1):i.push(0),e=e.shiftRight(1);return i},toNumber:function(t){if(!t.lt(a.default("9007199254740992",10)))throw new Error("Number too big");return t.toJSNumber()},toArray:function(t,e){return a.default(t).toArray(e)},add:function(t,e){return a.default(t).add(a.default(e))},sub:function(t,e){return a.default(t).minus(a.default(e))},neg:function(t){return a.default.zero.minus(a.default(t))},mul:function(t,e){return a.default(t).times(a.default(e))},square:function(t){return a.default(t).square()},pow:function(t,e){return a.default(t).pow(a.default(e))},exp:function(t,e){return a.default(t).pow(a.default(e))},abs:function(t){return a.default(t).abs()},div:function(t,e){return a.default(t).divide(a.default(e))},mod:function(t,e){return a.default(t).mod(a.default(e))},eq:function(t,e){return a.default(t).eq(a.default(e))},neq:function(t,e){return a.default(t).neq(a.default(e))},lt:function(t,e){return a.default(t).lt(a.default(e))},gt:function(t,e){return a.default(t).gt(a.default(e))},leq:function(t,e){return a.default(t).leq(a.default(e))},geq:function(t,e){return a.default(t).geq(a.default(e))},band:function(t,e){return a.default(t).and(a.default(e))},bor:function(t,e){return a.default(t).or(a.default(e))},bxor:function(t,e){return a.default(t).xor(a.default(e))},land:function(t,e){return!a.default(t).isZero()&&!a.default(e).isZero()},lor:function(t,e){return!a.default(t).isZero()||!a.default(e).isZero()},lnot:function(t){return a.default(t).isZero()}});const x="function"===typeof BigInt;let M={};x?Object.assign(M,v):Object.assign(M,R),M.toRprLE=function(t,e,i,n){const s="0000000"+i.toString(16),r=new Uint32Array(t.buffer,e,n/4),h=1+(4*(s.length-7)-1>>5);for(let o=0;o<h;o++)r[o]=parseInt(s.substring(s.length-8*o-8,s.length-8*o),16);for(let o=h;o<r.length;o++)r[o]=0;for(let o=4*r.length;o<n;o++)t[o]=M.toNumber(M.band(M.shiftRight(i,8*o),255))},M.toRprBE=function(t,e,i,n){const s="0000000"+i.toString(16),r=new DataView(t.buffer,t.byteOffset+e,n),h=1+(4*(s.length-7)-1>>5);for(let o=0;o<h;o++)r.setUint32(n-4*o-4,parseInt(s.substring(s.length-8*o-8,s.length-8*o),16),!1);for(let o=0;o<n/4-h;o++)r[o]=0},M.fromRprLE=function(t,e,i){i=i||t.byteLength;const n=new Uint32Array(t.buffer,e,i/4),s=new Array(i/4);return n.forEach(((t,e)=>s[s.length-e-1]=t.toString(16).padStart(8,"0"))),M.fromString(s.join(""),16)},M.fromRprBE=function(t,e,i){i=i||t.byteLength;const n=new DataView(t.buffer,t.byteOffset+e,i),s=new Array(i/4);for(let r=0;r<i/4;r++)s[r]=n.getUint32(4*r,!1).toString(16).padStart(8,"0");return M.fromString(s.join(""),16)},M.toString=function(t,e){return t.toString(e)},M.toLEBuff=function(t){const e=new Uint8Array(Math.floor((M.bitLength(t)-1)/8)+1);return M.toRprLE(e,0,t,e.byteLength),e},M.zero=M.e(0),M.one=M.e(1);let{toRprLE:z,toRprBE:S,fromRprLE:I,fromRprBE:U,toString:N,toLEBuff:C,zero:T,one:G,fromString:j,e:Z,fromArray:k,bitLength:$,isNegative:P,isZero:J,shiftLeft:D,shiftRight:X,shl:Q,shr:W,isOdd:V,naf:K,bits:H,toNumber:Y,toArray:tt,add:et,sub:it,neg:nt,mul:st,square:rt,pow:ht,exp:ot,abs:ft,div:ut,mod:at,eq:lt,neq:pt,lt:ct,gt:mt,leq:gt,geq:dt,band:Ft,bor:bt,bxor:wt,land:yt,lor:Lt,lnot:vt}=M;var Bt=Object.freeze({__proto__:null,toRprLE:z,toRprBE:S,fromRprLE:I,fromRprBE:U,toString:N,toLEBuff:C,zero:T,one:G,fromString:j,e:Z,fromArray:k,bitLength:$,isNegative:P,isZero:J,shiftLeft:D,shiftRight:X,shl:Q,shr:W,isOdd:V,naf:K,bits:H,toNumber:Y,toArray:tt,add:et,sub:it,neg:nt,mul:st,square:rt,pow:ht,exp:ot,abs:ft,div:ut,mod:at,eq:lt,neq:pt,lt:ct,gt:mt,leq:gt,geq:dt,band:Ft,bor:bt,bxor:wt,land:yt,lor:Lt,lnot:vt});function Et(t){return(0!==(4294901760&t)?(t&=4294901760,16):0)|(0!==(4278255360&t)?(t&=4278255360,8):0)|(0!==(4042322160&t)?(t&=4042322160,4):0)|(0!==(3435973836&t)?(t&=3435973836,2):0)|0!==(2863311530&t)}function qt(t,e,i,n,s){const r=1<<i;if(1==r)return[e[n]];if(2==r)return[t.F.add(e[n],e[n+s]),t.F.sub(e[n],e[n+s])];const h=r>>1,o=qt(t,e,i-1,n,2*s),f=qt(t,e,i-1,n+s,2*s),u=new Array(r);for(let a=0;a<h;a++)u[a]=t.F.add(o[a],t.F.mul(t.roots[i][a],f[a])),u[a+h]=t.F.sub(o[a],t.F.mul(t.roots[i][a],f[a]));return u}function Ot(t,e,i){const n=1<<i;if(1==n)return[e[0]];const s=n>>1,r=Ot(t,e.slice(0,s),i-1),h=Ot(t,e.slice(s),i-1),o=new Array(n);for(let f=0;f<s;f++)o[f]=t.F.add(r[f],t.F.mul(t.roots[i][f],h[f])),o[f+s]=t.F.sub(r[f],t.F.mul(t.roots[i][f],h[f]));return o}const _t=[];for(let Me=0;Me<256;Me++)_t[Me]=At(Me,8);function At(t,e){let i=0,n=t;for(let s=0;s<e;s++)i<<=1,i|=1&n,n>>=1;return i}function Rt(t,e){return(_t[t>>>24]|_t[t>>>16&255]<<8|_t[t>>>8&255]<<16|_t[255&t]<<24)>>>32-e}function xt(t,e){for(let i=0;i<t.length;i++){const n=Rt(i,e);if(n>i){const e=t[i];t[i]=t[n],t[n]=e}}}function Mt(t,e,i){let n;if(J(i))return t.zero;const s=K(i);if(1==s[s.length-1])n=e;else{if(-1!=s[s.length-1])throw new Error("invlaud NAF");n=t.neg(e)}for(let r=s.length-2;r>=0;r--)n=t.double(n),1==s[r]?n=t.add(n,e):-1==s[r]&&(n=t.sub(n,e));return n}function zt(t,e,i){if(J(i))return t.one;const n=H(i);if(0==n.legth)return t.one;let s=e;for(let r=n.length-2;r>=0;r--)s=t.square(s),n[r]&&(s=t.mul(s,e));return s}function St(t){if(t.m%2==1)if(lt(at(t.p,4),1))if(lt(at(t.p,8),1))if(lt(at(t.p,16),1))!function(t){t.sqrt_q=ht(t.p,t.m),t.sqrt_s=0,t.sqrt_t=it(t.sqrt_q,1);for(;!V(t.sqrt_t);)t.sqrt_s=t.sqrt_s+1,t.sqrt_t=ut(t.sqrt_t,2);let e=t.one;for(;t.eq(e,t.one);){const i=t.random();t.sqrt_z=t.pow(i,t.sqrt_t),e=t.pow(t.sqrt_z,2**(t.sqrt_s-1))}t.sqrt_tm1d2=ut(it(t.sqrt_t,1),2),t.sqrt=function(t){const e=this;if(e.isZero(t))return e.zero;let i=e.pow(t,e.sqrt_tm1d2);const n=e.pow(e.mul(e.square(i),t),2**(e.sqrt_s-1));if(e.eq(n,e.negone))return null;let s=e.sqrt_s,r=e.mul(t,i),h=e.mul(r,i),o=e.sqrt_z;for(;!e.eq(h,e.one);){let t=e.square(h),n=1;for(;!e.eq(t,e.one);)t=e.square(t),n++;i=o;for(let r=0;r<s-n-1;r++)i=e.square(i);o=e.square(i),h=e.mul(h,o),r=e.mul(r,i),s=n}return e.geq(r,e.zero)?r:e.neg(r)}}(t);else{if(!lt(at(t.p,16),9))throw new Error("Field withot sqrt");!function(t){t.sqrt=function(){throw new Error("Sqrt alg 4 not implemented")}}(t)}else{if(!lt(at(t.p,8),5))throw new Error("Field withot sqrt");!function(t){t.sqrt=function(){throw new Error("Sqrt alg 3 not implemented")}}(t)}else lt(at(t.p,4),3)&&function(t){t.sqrt_q=ht(t.p,t.m),t.sqrt_e1=ut(it(t.sqrt_q,3),4),t.sqrt=function(e){if(this.isZero(e))return this.zero;const i=this.pow(e,this.sqrt_e1),n=this.mul(this.square(i),e);if(this.eq(n,this.negone))return null;const s=this.mul(i,e);return t.geq(s,t.zero)?s:t.neg(s)}}(t);else{const e=at(ht(t.p,t.m/2),4);1==e?function(t){t.sqrt=function(){throw new Error("Sqrt alg 10 not implemented")}}(t):3==e?function(t){t.sqrt_q=ht(t.p,t.m/2),t.sqrt_e34=ut(it(t.sqrt_q,3),4),t.sqrt_e12=ut(it(t.sqrt_q,1),2),t.frobenius=function(e,i){return e%2==1?t.conjugate(i):i},t.sqrt=function(t){const e=this,i=e.pow(t,e.sqrt_e34),n=e.mul(e.square(i),t),s=e.mul(e.frobenius(1,n),n);if(e.eq(s,e.negone))return null;const r=e.mul(i,t);let h;if(e.eq(n,e.negone))h=e.mul(r,[e.F.zero,e.F.one]);else{const t=e.pow(e.add(e.one,n),e.sqrt_e12);h=e.mul(t,r)}return e.geq(h,e.zero)?h:e.neg(h)}}(t):function(t){t.sqrt=function(){throw new Error("Sqrt alg 8 not implemented")}}(t)}}function It(t,e,i,n,s){t[e]=t[e]+t[i]>>>0,t[s]=(t[s]^t[e])>>>0,t[s]=(t[s]<<16|t[s]>>>16&65535)>>>0,t[n]=t[n]+t[s]>>>0,t[i]=(t[i]^t[n])>>>0,t[i]=(t[i]<<12|t[i]>>>20&4095)>>>0,t[e]=t[e]+t[i]>>>0,t[s]=(t[s]^t[e])>>>0,t[s]=(t[s]<<8|t[s]>>>24&255)>>>0,t[n]=t[n]+t[s]>>>0,t[i]=(t[i]^t[n])>>>0,t[i]=(t[i]<<7|t[i]>>>25&127)>>>0}class Ut{constructor(t){t=t||[0,0,0,0,0,0,0,0],this.state=[1634760805,857760878,2036477234,1797285236,t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],0,0,0,0],this.idx=16,this.buff=new Array(16)}nextU32(){return 16==this.idx&&this.update(),this.buff[this.idx++]}nextU64(){return et(st(this.nextU32(),4294967296),this.nextU32())}nextBool(){return 1==(1&this.nextU32())}update(){for(let e=0;e<16;e++)this.buff[e]=this.state[e];for(let e=0;e<10;e++)It(t=this.buff,0,4,8,12),It(t,1,5,9,13),It(t,2,6,10,14),It(t,3,7,11,15),It(t,0,5,10,15),It(t,1,6,11,12),It(t,2,7,8,13),It(t,3,4,9,14);var t;for(let e=0;e<16;e++)this.buff[e]=this.buff[e]+this.state[e]>>>0;this.idx=0,this.state[12]=this.state[12]+1>>>0,0==this.state[12]&&(this.state[13]=this.state[13]+1>>>0,0==this.state[13]&&(this.state[14]=this.state[14]+1>>>0,0==this.state[14]&&(this.state[15]=this.state[15]+1>>>0)))}}function Nt(t){let e=new Uint8Array(t);if("undefined"!==typeof window)if("undefined"!==typeof window.crypto)window.crypto.getRandomValues(e);else for(let i=0;i<t;i++)e[i]=4294967296*Math.random()>>>0;else l.default.randomFillSync(e);return e}let Ct=null;function Tt(){return Ct||(Ct=new Ut(function(){const t=Nt(32),e=new Uint32Array(t.buffer),i=[];for(let n=0;n<8;n++)i.push(e[n]);return i}()),Ct)}class Gt{constructor(t){this.type="F1",this.one=1n,this.zero=0n,this.p=BigInt(t),this.m=1,this.negone=this.p-1n,this.two=2n,this.half=this.p>>1n,this.bitLength=$(this.p),this.mask=(1n<<BigInt(this.bitLength))-1n,this.n64=Math.floor((this.bitLength-1)/64)+1,this.n32=2*this.n64,this.n8=8*this.n64,this.R=this.e(1n<<BigInt(64*this.n64)),this.Ri=this.inv(this.R);const e=this.negone>>1n;this.nqr=this.two;let i=this.pow(this.nqr,e);for(;!this.eq(i,this.negone);)this.nqr=this.nqr+1n,i=this.pow(this.nqr,e);for(this.s=0,this.t=this.negone;0n==(1n&this.t);)this.s=this.s+1,this.t=this.t>>1n;this.nqr_to_t=this.pow(this.nqr,this.t),St(this)}e(t,e){let i;if(e?16==e&&(i=BigInt("0x"+t)):i=BigInt(t),i<0){let t=-i;return t>=this.p&&(t%=this.p),this.p-t}return i>=this.p?i%this.p:i}add(t,e){const i=t+e;return i>=this.p?i-this.p:i}sub(t,e){return t>=e?t-e:this.p-e+t}neg(t){return t?this.p-t:t}mul(t,e){return t*e%this.p}mulScalar(t,e){return t*this.e(e)%this.p}square(t){return t*t%this.p}eq(t,e){return t==e}neq(t,e){return t!=e}lt(t,e){return(t>this.half?t-this.p:t)<(e>this.half?e-this.p:e)}gt(t,e){return(t>this.half?t-this.p:t)>(e>this.half?e-this.p:e)}leq(t,e){return(t>this.half?t-this.p:t)<=(e>this.half?e-this.p:e)}geq(t,e){return(t>this.half?t-this.p:t)>=(e>this.half?e-this.p:e)}div(t,e){return this.mul(t,this.inv(e))}idiv(t,e){if(!e)throw new Error("Division by zero");return t/e}inv(t){if(!t)throw new Error("Division by zero");let e=0n,i=this.p,n=1n,s=t%this.p;for(;s;){let t=i/s;[e,n]=[n,e-t*n],[i,s]=[s,i-t*s]}return e<0n&&(e+=this.p),e}mod(t,e){return t%e}pow(t,e){return zt(this,t,e)}exp(t,e){return zt(this,t,e)}band(t,e){const i=t&e&this.mask;return i>=this.p?i-this.p:i}bor(t,e){const i=(t|e)&this.mask;return i>=this.p?i-this.p:i}bxor(t,e){const i=(t^e)&this.mask;return i>=this.p?i-this.p:i}bnot(t){const e=t^this.mask;return e>=this.p?e-this.p:e}shl(t,e){if(Number(e)<this.bitLength){const i=t<<e&this.mask;return i>=this.p?i-this.p:i}{const i=this.p-e;return Number(i)<this.bitLength?t>>i:0n}}shr(t,e){if(Number(e)<this.bitLength)return t>>e;{const i=this.p-e;if(Number(i)<this.bitLength){const e=t<<i&this.mask;return e>=this.p?e-this.p:e}return 0}}land(t,e){return t&&e?1n:0n}lor(t,e){return t||e?1n:0n}lnot(t){return t?0n:1n}sqrt_old(t){if(0n==t)return this.zero;if(1n!=this.pow(t,this.negone>>this.one))return null;let e=this.s,i=this.nqr_to_t,n=this.pow(t,this.t),s=this.pow(t,this.add(this.t,this.one)>>1n);for(;1n!=n;){let t=this.square(n),r=1;for(;1n!=t;)r++,t=this.square(t);let h=i;for(let i=0;i<e-r-1;i++)h=this.square(h);e=r,i=this.square(h),n=this.mul(n,i),s=this.mul(s,h)}return s>this.p>>1n&&(s=this.neg(s)),s}normalize(t,e){if((t=BigInt(t,e))<0){let e=-t;return e>=this.p&&(e%=this.p),this.p-e}return t>=this.p?t%this.p:t}random(){const t=2*this.bitLength/8;let e=0n;for(let i=0;i<t;i++)e=(e<<8n)+BigInt(Nt(1)[0]);return e%this.p}toString(t,e){let i;if(t>this.half){i="-"+(this.p-t).toString(e)}else i=t.toString(e);return i}isZero(t){return 0n==t}fromRng(t){let e;do{e=0n;for(let i=0;i<this.n64;i++)e+=t.nextU64()<<BigInt(64*i);e&=this.mask}while(e>=this.p);return e=e*this.Ri%this.p,e}}class jt{constructor(t){this.type="F1",this.one=a.default.one,this.zero=a.default.zero,this.p=a.default(t),this.m=1,this.negone=this.p.minus(a.default.one),this.two=a.default(2),this.half=this.p.shiftRight(1),this.bitLength=this.p.bitLength(),this.mask=a.default.one.shiftLeft(this.bitLength).minus(a.default.one),this.n64=Math.floor((this.bitLength-1)/64)+1,this.n32=2*this.n64,this.n8=8*this.n64,this.R=a.default.one.shiftLeft(64*this.n64),this.Ri=this.inv(this.R);const e=this.negone.shiftRight(this.one);this.nqr=this.two;let i=this.pow(this.nqr,e);for(;!i.equals(this.negone);)this.nqr=this.nqr.add(this.one),i=this.pow(this.nqr,e);for(this.s=this.zero,this.t=this.negone;!this.t.isOdd();)this.s=this.s.add(this.one),this.t=this.t.shiftRight(this.one);this.nqr_to_t=this.pow(this.nqr,this.t),St(this)}e(t,e){const i=a.default(t,e);return this.normalize(i)}add(t,e){let i=t.add(e);return i.geq(this.p)&&(i=i.minus(this.p)),i}sub(t,e){return t.geq(e)?t.minus(e):this.p.minus(e.minus(t))}neg(t){return t.isZero()?t:this.p.minus(t)}mul(t,e){return t.times(e).mod(this.p)}mulScalar(t,e){return t.times(a.default(e)).mod(this.p)}square(t){return t.square().mod(this.p)}eq(t,e){return t.eq(e)}neq(t,e){return t.neq(e)}lt(t,e){const i=t.gt(this.half)?t.minus(this.p):t,n=e.gt(this.half)?e.minus(this.p):e;return i.lt(n)}gt(t,e){const i=t.gt(this.half)?t.minus(this.p):t,n=e.gt(this.half)?e.minus(this.p):e;return i.gt(n)}leq(t,e){const i=t.gt(this.half)?t.minus(this.p):t,n=e.gt(this.half)?e.minus(this.p):e;return i.leq(n)}geq(t,e){const i=t.gt(this.half)?t.minus(this.p):t,n=e.gt(this.half)?e.minus(this.p):e;return i.geq(n)}div(t,e){if(e.isZero())throw new Error("Division by zero");return t.times(e.modInv(this.p)).mod(this.p)}idiv(t,e){if(e.isZero())throw new Error("Division by zero");return t.divide(e)}inv(t){if(t.isZero())throw new Error("Division by zero");return t.modInv(this.p)}mod(t,e){return t.mod(e)}pow(t,e){return t.modPow(e,this.p)}exp(t,e){return t.modPow(e,this.p)}band(t,e){return t.and(e).and(this.mask).mod(this.p)}bor(t,e){return t.or(e).and(this.mask).mod(this.p)}bxor(t,e){return t.xor(e).and(this.mask).mod(this.p)}bnot(t){return t.xor(this.mask).mod(this.p)}shl(t,e){if(e.lt(this.bitLength))return t.shiftLeft(e).and(this.mask).mod(this.p);{const i=this.p.minus(e);return i.lt(this.bitLength)?this.shr(t,i):a.default.zero}}shr(t,e){if(e.lt(this.bitLength))return t.shiftRight(e);{const i=this.p.minus(e);return i.lt(this.bitLength)?this.shl(t,i):a.default.zero}}land(t,e){return t.isZero()||e.isZero()?a.default.zero:a.default.one}lor(t,e){return t.isZero()&&e.isZero()?a.default.zero:a.default.one}lnot(t){return t.isZero()?a.default.one:a.default.zero}sqrt_old(t){if(t.equals(this.zero))return this.zero;if(!this.pow(t,this.negone.shiftRight(this.one)).equals(this.one))return null;let e=parseInt(this.s),i=this.nqr_to_t,n=this.pow(t,this.t),s=this.pow(t,this.add(this.t,this.one).shiftRight(this.one));for(;!n.equals(this.one);){let t=this.square(n),r=1;for(;!t.equals(this.one);)r++,t=this.square(t);let h=i;for(let i=0;i<e-r-1;i++)h=this.square(h);e=r,i=this.square(h),n=this.mul(n,i),s=this.mul(s,h)}return s.greater(this.p.shiftRight(this.one))&&(s=this.neg(s)),s}normalize(t){return(t=a.default(t)).isNegative()?this.p.minus(t.abs().mod(this.p)):t.mod(this.p)}random(){let t=a.default(0),e=a.default(this.p.square());for(;!e.isZero();)t=t.shiftLeft(8).add(a.default(Nt(1)[0])),e=e.shiftRight(8);return t.mod(this.p)}toString(t,e){let i;if(t.lesserOrEquals(this.p.shiftRight(a.default(1))))i=t.toString(e);else{i="-"+this.p.minus(t).toString(e)}return i}isZero(t){return t.isZero()}fromRng(t){let e;do{e=a.default(0);for(let i=0;i<this.n64;i++)e=e.add(e,t.nextU64().shiftLeft(64*i));e=e.and(this.mask)}while(e.geq(this.p));return e=e.times(this.Ri).mod(this.q),e}}const Zt="function"===typeof BigInt;let kt;kt=Zt?Gt:jt;class $t extends kt{toRprLE(t,e,i){z(t,e,i,8*this.n64)}toRprBE(t,e,i){S(t,e,i,8*this.n64)}toRprBEM(t,e,i){return this.toRprBE(t,e,this.mul(this.R,i))}toRprLEM(t,e,i){return this.toRprLE(t,e,this.mul(this.R,i))}fromRprLE(t,e){return I(t,e,this.n8)}fromRprBE(t,e){return U(t,e,this.n8)}fromRprLEM(t,e){return this.mul(this.fromRprLE(t,e),this.Ri)}fromRprBEM(t,e){return this.mul(this.fromRprBE(t,e),this.Ri)}}function Pt(t,e){if(Array.isArray(e)){for(let i=e.length-1;i>=0;i--)if(!t.F.isZero(e[i]))return Pt(t.F,e[i]);return 0}{const i=t.neg(e);return mt(e,i)}}var Jt=Object.freeze({__proto__:null,stringifyBigInts:function t(e){if("bigint"==typeof e||void 0!==e.eq)return e.toString(10);if(e instanceof Uint8Array)return I(e,0);if(Array.isArray(e))return e.map(t);if("object"==typeof e){const i={};return Object.keys(e).forEach((n=>{i[n]=t(e[n])})),i}return e},unstringifyBigInts:function t(e){if("string"==typeof e&&/^[0-9]+$/.test(e))return BigInt(e);if(Array.isArray(e))return e.map(t);if("object"==typeof e){if(null===e)return null;const i={};return Object.keys(e).forEach((n=>{i[n]=t(e[n])})),i}return e},beBuff2int:function(t){let e=0n,i=t.length,n=0;const s=new DataView(t.buffer,t.byteOffset,t.byteLength);for(;i>0;)i>=4?(i-=4,e+=BigInt(s.getUint32(i))<<BigInt(8*n),n+=4):i>=2?(i-=2,e+=BigInt(s.getUint16(i))<<BigInt(8*n),n+=2):(i-=1,e+=BigInt(s.getUint8(i))<<BigInt(8*n),n+=1);return e},beInt2Buff:function(t,e){let i=t;const n=new Uint8Array(e),s=new DataView(n.buffer);let r=e;for(;r>0;)r-4>=0?(r-=4,s.setUint32(r,Number(0xFFFFFFFFn&i)),i>>=32n):r-2>=0?(r-=2,s.setUint16(r,Number(0xFFFFn&i)),i>>=16n):(r-=1,s.setUint8(r,Number(0xFFn&i)),i>>=8n);if(i)throw new Error("Number does not fit in this length");return n},leBuff2int:function(t){let e=0n,i=0;const n=new DataView(t.buffer,t.byteOffset,t.byteLength);for(;i<t.length;)i+4<=t.length?(e+=BigInt(n.getUint32(i,!0))<<BigInt(8*i),i+=4):i+4<=t.length?(e+=BigInt(n.getUint16(i,!0))<<BigInt(8*i),i+=2):(e+=BigInt(n.getUint8(i,!0))<<BigInt(8*i),i+=1);return e},leInt2Buff:function(t,e){let i=t;"undefined"===typeof e&&0==(e=Math.floor(($(t)-1)/8)+1)&&(e=1);const n=new Uint8Array(e),s=new DataView(n.buffer);let r=0;for(;r<e;)r+4<=e?(s.setUint32(r,Number(0xFFFFFFFFn&i),!0),r+=4,i>>=32n):r+2<=e?(s.setUint16(Number(r,0xFFFFn&i),!0),r+=2,i>>=16n):(s.setUint8(Number(r,0xFFn&i),!0),r+=1,i>>=8n);if(i)throw new Error("Number does not fit in this length");return n}});var Dt=Object.freeze({__proto__:null,stringifyBigInts:function t(e){if("bigint"==typeof e||void 0!==e.eq)return e.toString(10);if(Array.isArray(e))return e.map(t);if("object"==typeof e){const i={};return Object.keys(e).forEach((n=>{i[n]=t(e[n])})),i}return e},unstringifyBigInts:function t(e){if("string"==typeof e&&/^[0-9]+$/.test(e))return a.default(e);if(Array.isArray(e))return e.map(t);if("object"==typeof e){const i={};return Object.keys(e).forEach((n=>{i[n]=t(e[n])})),i}return e},beBuff2int:function(t){let e=a.default.zero;for(let i=0;i<t.length;i++){const n=a.default(t[t.length-i-1]);e=e.add(n.shiftLeft(8*i))}return e},beInt2Buff:function(t,e){let i=t,n=e-1;const s=new Uint8Array(e);for(;i.gt(a.default.zero)&&n>=0;){let t=Number(i.and(a.default("255")));s[n]=t,n--,i=i.shiftRight(8)}if(!i.eq(a.default.zero))throw new Error("Number does not fit in this length");return s},leBuff2int:function(t){let e=a.default.zero;for(let i=0;i<t.length;i++){const n=a.default(t[i]);e=e.add(n.shiftLeft(8*i))}return e},leInt2Buff:function(t,e){let i=t,n=0;const s=new Uint8Array(e);for(;i.gt(a.default.zero)&&n<s.length;){let t=Number(i.and(a.default(255)));s[n]=t,n++,i=i.shiftRight(8)}if(!i.eq(a.default.zero))throw new Error("Number does not fit in this length");return s}});let Xt={};"function"===typeof BigInt?Object.assign(Xt,Jt):Object.assign(Xt,Dt);const Qt=[];for(let Me=0;Me<256;Me++)Qt[Me]=Wt(Me,8);function Wt(t,e){let i=0,n=t;for(let s=0;s<e;s++)i<<=1,i|=1&n,n>>=1;return i}Xt.bitReverse=function(t,e){return(Qt[t>>>24]|Qt[t>>>16&255]<<8|Qt[t>>>8&255]<<16|Qt[255&t]<<24)>>>32-e},Xt.log2=function(t){return(0!==(4294901760&t)?(t&=4294901760,16):0)|(0!==(4278255360&t)?(t&=4278255360,8):0)|(0!==(4042322160&t)?(t&=4042322160,4):0)|(0!==(3435973836&t)?(t&=3435973836,2):0)|0!==(2863311530&t)},Xt.buffReverseBits=function(t,e){const i=t.byteLength/e,n=Xt.log2(i);if(i!=1<<n)throw new Error("Invalid number of pointers");for(let s=0;s<i;s++){const i=Xt.bitReverse(s,n);if(s>i){const n=t.slice(s*e,(s+1)*e);t.set(t.slice(i*e,(i+1)*e),s*e),t.set(n,i*e)}}};let{bitReverse:Vt,log2:Kt,buffReverseBits:Ht,stringifyBigInts:Yt,unstringifyBigInts:te,beBuff2int:ee,beInt2Buff:ie,leBuff2int:ne,leInt2Buff:se}=Xt;var re=Object.freeze({__proto__:null,bitReverse:Vt,log2:Kt,buffReverseBits:Ht,stringifyBigInts:Yt,unstringifyBigInts:te,beBuff2int:ee,beInt2Buff:ie,leBuff2int:ne,leInt2Buff:se});const he=1<<30;class oe{constructor(t){this.buffers=[],this.byteLength=t;for(let e=0;e<t;e+=he){const i=Math.min(t-e,he);this.buffers.push(new Uint8Array(i))}}slice(t,e){void 0===e&&(e=this.byteLength),void 0===t&&(t=0);const i=e-t,n=Math.floor(t/he);if(n==Math.floor((t+i-1)/he)||0==i)return this.buffers[n].slice(t%he,t%he+i);let s,r=n,h=t%he,o=i;for(;o>0;){const t=h+o>he?he-h:o,e=new Uint8Array(this.buffers[r].buffer,this.buffers[r].byteOffset+h,t);if(t==i)return e.slice();s||(s=i<=he?new Uint8Array(i):new oe(i)),s.set(e,i-o),o-=t,r++,h=0}return s}set(t,e){void 0===e&&(e=0);const i=t.byteLength;if(0==i)return;const n=Math.floor(e/he);if(n==Math.floor((e+i-1)/he))return this.buffers[n].set(t,e%he);let s=n,r=e%he,h=i;for(;h>0;){const e=r+h>he?he-r:h,n=t.slice(i-h,i-h+e);new Uint8Array(this.buffers[s].buffer,this.buffers[s].byteOffset+r,e).set(n),h-=e,s++,r=0}}}function fe(t,e,i,n){return async function(s){const r=Math.floor(s.byteLength/i);if(r*i!==s.byteLength)throw new Error("Invalid buffer size");const h=Math.floor(r/t.concurrency),o=[];for(let l=0;l<t.concurrency;l++){let f;if(f=l<t.concurrency-1?h:r-l*h,0==f)continue;const u=[{cmd:"ALLOCSET",var:0,buff:s.slice(l*h*i,l*h*i+f*i)},{cmd:"ALLOC",var:1,len:n*f},{cmd:"CALL",fnName:e,params:[{var:0},{val:f},{var:1}]},{cmd:"GET",out:0,var:1,len:n*f}];o.push(t.queueAction(u))}const f=await Promise.all(o);let u;u=s instanceof oe?new oe(r*n):new Uint8Array(r*n);let a=0;for(let t=0;t<f.length;t++)u.set(f[t][0],a),a+=f[t][0].byteLength;return u}}class ue{constructor(t,e,i,n){if(this.tm=t,this.prefix=e,this.p=n,this.n8=i,this.type="F1",this.m=1,this.half=X(n,G),this.bitLength=$(n),this.mask=it(D(G,this.bitLength),G),this.pOp1=t.alloc(i),this.pOp2=t.alloc(i),this.pOp3=t.alloc(i),this.tm.instance.exports[e+"_zero"](this.pOp1),this.zero=this.tm.getBuff(this.pOp1,this.n8),this.tm.instance.exports[e+"_one"](this.pOp1),this.one=this.tm.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one),this.n64=Math.floor(i/8),this.n32=Math.floor(i/4),8*this.n64!=this.n8)throw new Error("n8 must be a multiple of 8");this.half=X(this.p,G),this.nqr=this.two;let s=this.exp(this.nqr,this.half);for(;!this.eq(s,this.negone);)this.nqr=this.add(this.nqr,this.one),s=this.exp(this.nqr,this.half);this.shift=this.mul(this.nqr,this.nqr),this.shiftInv=this.inv(this.shift),this.s=0;let r=it(this.p,G);for(;!V(r);)this.s=this.s+1,r=X(r,G);this.w=[],this.w[this.s]=this.exp(this.nqr,r);for(let h=this.s-1;h>=0;h--)this.w[h]=this.square(this.w[h+1]);if(!this.eq(this.w[0],this.one))throw new Error("Error calculating roots of unity");this.batchToMontgomery=fe(t,e+"_batchToMontgomery",this.n8,this.n8),this.batchFromMontgomery=fe(t,e+"_batchFromMontgomery",this.n8,this.n8)}op2(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,e){return this.tm.setBuff(this.pOp1,e),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,e){return this.tm.setBuff(this.pOp1,e),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,e){return this.op2("_add",t,e)}eq(t,e){return this.op2Bool("_eq",t,e)}isZero(t){return this.op1Bool("_isZero",t)}sub(t,e){return this.op2("_sub",t,e)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,e){return this.op2("_mul",t,e)}div(t,e){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,e){return e instanceof Uint8Array||(e=C(Z(e))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,e.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}isNegative(t){return this.op1Bool("_isNegative",t)}e(t,e){if(t instanceof Uint8Array)return t;let i=Z(t,e);P(i)?(i=nt(i),mt(i,this.p)&&(i=at(i,this.p)),i=it(this.p,i)):mt(i,this.p)&&(i=at(i,this.p));const n=se(i,this.n8);return this.toMontgomery(n)}toString(t,e){const i=this.fromMontgomery(t),n=I(i,0);return N(n,e)}fromRng(t){let e;const i=new Uint8Array(this.n8);do{e=T;for(let i=0;i<this.n64;i++)e=et(e,D(t.nextU64(),64*i));e=Ft(e,this.mask)}while(dt(e,this.p));return z(i,0,e,this.n8),i}random(){return this.fromRng(Tt())}toObject(t){const e=this.fromMontgomery(t);return I(e,0)}fromObject(t){const e=new Uint8Array(this.n8);return z(e,0,t,this.n8),this.toMontgomery(e)}toRprLE(t,e,i){t.set(this.fromMontgomery(i),e)}fromRprLE(t,e){e=e||0;const i=t.slice(e,e+this.n8);return this.toMontgomery(i)}}class ae{constructor(t,e,i){this.tm=t,this.prefix=e,this.F=i,this.type="F2",this.m=2*i.m,this.n8=2*this.F.n8,this.n32=2*this.F.n32,this.n64=2*this.F.n64,this.pOp1=t.alloc(2*i.n8),this.pOp2=t.alloc(2*i.n8),this.pOp3=t.alloc(2*i.n8),this.tm.instance.exports[e+"_zero"](this.pOp1),this.zero=t.getBuff(this.pOp1,this.n8),this.tm.instance.exports[e+"_one"](this.pOp1),this.one=t.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one)}op2(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,e){return this.tm.setBuff(this.pOp1,e),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,e){return this.tm.setBuff(this.pOp1,e),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,e){return this.op2("_add",t,e)}eq(t,e){return this.op2Bool("_eq",t,e)}isZero(t){return this.op1Bool("_isZero",t)}sub(t,e){return this.op2("_sub",t,e)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}isNegative(t){return this.op1Bool("_isNegative",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,e){return this.op2("_mul",t,e)}mul1(t,e){return this.op2("_mul1",t,e)}div(t,e){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,e){return e instanceof Uint8Array||(e=C(Z(e))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,e.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}e(t,e){if(t instanceof Uint8Array)return t;if(Array.isArray(t)&&2==t.length){const i=this.F.e(t[0],e),n=this.F.e(t[1],e),s=new Uint8Array(2*this.F.n8);return s.set(i),s.set(n,2*this.F.n8),s}throw new Error("invalid F2")}toString(t,e){return`[${this.F.toString(t.slice(0,this.F.n8),e)}, ${this.F.toString(t.slice(this.F.n8),e)}]`}fromRng(t){const e=this.F.fromRng(t),i=this.F.fromRng(t),n=new Uint8Array(2*this.F.n8);return n.set(e),n.set(i,this.F.n8),n}random(){return this.fromRng(Tt())}toObject(t){return[this.F.toObject(t.slice(0,this.F.n8)),this.F.toObject(t.slice(this.F.n8,2*this.F.n8))]}fromObject(t){const e=new Uint8Array(2*this.F.n8),i=this.F.fromObject(t[0]),n=this.F.fromObject(t[1]);return e.set(i),e.set(n,this.F.n8),e}c1(t){return t.slice(0,this.F.n8)}c2(t){return t.slice(this.F.n8)}}class le{constructor(t,e,i){this.tm=t,this.prefix=e,this.F=i,this.type="F3",this.m=3*i.m,this.n8=3*this.F.n8,this.n32=3*this.F.n32,this.n64=3*this.F.n64,this.pOp1=t.alloc(3*i.n8),this.pOp2=t.alloc(3*i.n8),this.pOp3=t.alloc(3*i.n8),this.tm.instance.exports[e+"_zero"](this.pOp1),this.zero=t.getBuff(this.pOp1,this.n8),this.tm.instance.exports[e+"_one"](this.pOp1),this.one=t.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one)}op2(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,e){return this.tm.setBuff(this.pOp1,e),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,e){return this.tm.setBuff(this.pOp1,e),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}eq(t,e){return this.op2Bool("_eq",t,e)}isZero(t){return this.op1Bool("_isZero",t)}add(t,e){return this.op2("_add",t,e)}sub(t,e){return this.op2("_sub",t,e)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}isNegative(t){return this.op1Bool("_isNegative",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,e){return this.op2("_mul",t,e)}div(t,e){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,e){return e instanceof Uint8Array||(e=C(Z(e))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,e.byteLength,this.pOp3),this.getBuff(this.pOp3,this.n8)}e(t,e){if(t instanceof Uint8Array)return t;if(Array.isArray(t)&&3==t.length){const i=this.F.e(t[0],e),n=this.F.e(t[1],e),s=this.F.e(t[2],e),r=new Uint8Array(3*this.F.n8);return r.set(i),r.set(n,this.F.n8),r.set(s,2*this.F.n8),r}throw new Error("invalid F3")}toString(t,e){return`[${this.F.toString(t.slice(0,this.F.n8),e)}, ${this.F.toString(t.slice(this.F.n8,2*this.F.n8),e)}, ${this.F.toString(t.slice(2*this.F.n8),e)}]`}fromRng(t){const e=this.F.fromRng(t),i=this.F.fromRng(t),n=this.F.fromRng(t),s=new Uint8Array(3*this.F.n8);return s.set(e),s.set(i,this.F.n8),s.set(n,2*this.F.n8),s}random(){return this.fromRng(Tt())}toObject(t){return[this.F.toObject(t.slice(0,this.F.n8)),this.F.toObject(t.slice(this.F.n8,2*this.F.n8)),this.F.toObject(t.slice(2*this.F.n8,3*this.F.n8))]}fromObject(t){const e=new Uint8Array(3*this.F.n8),i=this.F.fromObject(t[0]),n=this.F.fromObject(t[1]),s=this.F.fromObject(t[2]);return e.set(i),e.set(n,this.F.n8),e.set(s,2*this.F.n8),e}c1(t){return t.slice(0,this.F.n8)}c2(t){return t.slice(this.F.n8,2*this.F.n8)}c3(t){return t.slice(2*this.F.n8)}}class pe{constructor(t,e,i,n,s,r){this.tm=t,this.prefix=e,this.F=i,this.pOp1=t.alloc(3*i.n8),this.pOp2=t.alloc(3*i.n8),this.pOp3=t.alloc(3*i.n8),this.tm.instance.exports[e+"_zero"](this.pOp1),this.zero=this.tm.getBuff(this.pOp1,3*i.n8),this.tm.instance.exports[e+"_zeroAffine"](this.pOp1),this.zeroAffine=this.tm.getBuff(this.pOp1,2*i.n8),this.one=this.tm.getBuff(n,3*i.n8),this.g=this.one,this.oneAffine=this.tm.getBuff(n,2*i.n8),this.gAffine=this.oneAffine,this.b=this.tm.getBuff(s,i.n8),r&&(this.cofactor=C(r)),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one),this.batchLEMtoC=fe(t,e+"_batchLEMtoC",2*i.n8,i.n8),this.batchLEMtoU=fe(t,e+"_batchLEMtoU",2*i.n8,2*i.n8),this.batchCtoLEM=fe(t,e+"_batchCtoLEM",i.n8,2*i.n8),this.batchUtoLEM=fe(t,e+"_batchUtoLEM",2*i.n8,2*i.n8),this.batchToJacobian=fe(t,e+"_batchToJacobian",2*i.n8,3*i.n8),this.batchToAffine=fe(t,e+"_batchToAffine",3*i.n8,2*i.n8)}op2(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}op2bool(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3)}op1(t,e){return this.tm.setBuff(this.pOp1,e),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}op1Affine(t,e){return this.tm.setBuff(this.pOp1,e),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,2*this.F.n8)}op1Bool(t,e){return this.tm.setBuff(this.pOp1,e),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,e){if(t.byteLength==3*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2("_add",t,e);if(e.byteLength==2*this.F.n8)return this.op2("_addMixed",t,e);throw new Error("invalid point size")}if(t.byteLength==2*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2("_addMixed",e,t);if(e.byteLength==2*this.F.n8)return this.op2("_addAffine",t,e);throw new Error("invalid point size")}throw new Error("invalid point size")}sub(t,e){if(t.byteLength==3*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2("_sub",t,e);if(e.byteLength==2*this.F.n8)return this.op2("_subMixed",t,e);throw new Error("invalid point size")}if(t.byteLength==2*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2("_subMixed",e,t);if(e.byteLength==2*this.F.n8)return this.op2("_subAffine",t,e);throw new Error("invalid point size")}throw new Error("invalid point size")}neg(t){if(t.byteLength==3*this.F.n8)return this.op1("_neg",t);if(t.byteLength==2*this.F.n8)return this.op1Affine("_negAffine",t);throw new Error("invalid point size")}double(t){if(t.byteLength==3*this.F.n8)return this.op1("_double",t);if(t.byteLength==2*this.F.n8)return this.op1("_doubleAffine",t);throw new Error("invalid point size")}isZero(t){if(t.byteLength==3*this.F.n8)return this.op1Bool("_isZero",t);if(t.byteLength==2*this.F.n8)return this.op1Bool("_isZeroAffine",t);throw new Error("invalid point size")}timesScalar(t,e){let i;if(e instanceof Uint8Array||(e=C(Z(e))),t.byteLength==3*this.F.n8)i=this.prefix+"_timesScalar";else{if(t.byteLength!=2*this.F.n8)throw new Error("invalid point size");i=this.prefix+"_timesScalarAffine"}return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[i](this.pOp1,this.pOp2,e.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}timesFr(t,e){let i;if(t.byteLength==3*this.F.n8)i=this.prefix+"_timesFr";else{if(t.byteLength!=2*this.F.n8)throw new Error("invalid point size");i=this.prefix+"_timesFrAffine"}return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[i](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}eq(t,e){if(t.byteLength==3*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2bool("_eq",t,e);if(e.byteLength==2*this.F.n8)return this.op2bool("_eqMixed",t,e);throw new Error("invalid point size")}if(t.byteLength==2*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2bool("_eqMixed",e,t);if(e.byteLength==2*this.F.n8)return this.op2bool("_eqAffine",t,e);throw new Error("invalid point size")}throw new Error("invalid point size")}toAffine(t){if(t.byteLength==3*this.F.n8)return this.op1Affine("_toAffine",t);if(t.byteLength==2*this.F.n8)return t;throw new Error("invalid point size")}toJacobian(t){if(t.byteLength==3*this.F.n8)return t;if(t.byteLength==2*this.F.n8)return this.op1("_toJacobian",t);throw new Error("invalid point size")}toRprUncompressed(t,e,i){if(this.tm.setBuff(this.pOp1,i),i.byteLength==3*this.F.n8)this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);else if(i.byteLength!=2*this.F.n8)throw new Error("invalid point size");this.tm.instance.exports[this.prefix+"_LEMtoU"](this.pOp1,this.pOp1);const n=this.tm.getBuff(this.pOp1,2*this.F.n8);t.set(n,e)}fromRprUncompressed(t,e){const i=t.slice(e,e+2*this.F.n8);return this.tm.setBuff(this.pOp1,i),this.tm.instance.exports[this.prefix+"_UtoLEM"](this.pOp1,this.pOp1),this.tm.getBuff(this.pOp1,2*this.F.n8)}toRprCompressed(t,e,i){if(this.tm.setBuff(this.pOp1,i),i.byteLength==3*this.F.n8)this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);else if(i.byteLength!=2*this.F.n8)throw new Error("invalid point size");this.tm.instance.exports[this.prefix+"_LEMtoC"](this.pOp1,this.pOp1);const n=this.tm.getBuff(this.pOp1,this.F.n8);t.set(n,e)}fromRprCompressed(t,e){const i=t.slice(e,e+this.F.n8);return this.tm.setBuff(this.pOp1,i),this.tm.instance.exports[this.prefix+"_CtoLEM"](this.pOp1,this.pOp2),this.tm.getBuff(this.pOp2,2*this.F.n8)}toUncompressed(t){const e=new Uint8Array(2*this.F.n8);return this.toRprUncompressed(e,0,t),e}toRprLEM(t,e,i){if(i.byteLength!=2*this.F.n8){if(i.byteLength!=3*this.F.n8)throw new Error("invalid point size");{this.tm.setBuff(this.pOp1,i),this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);const n=this.tm.getBuff(this.pOp1,2*this.F.n8);t.set(n,e)}}else t.set(i,e)}fromRprLEM(t,e){return e=e||0,t.slice(e,e+2*this.F.n8)}toString(t,e){if(t.byteLength==3*this.F.n8){return`[ ${this.F.toString(t.slice(0,this.F.n8),e)}, ${this.F.toString(t.slice(this.F.n8,2*this.F.n8),e)}, ${this.F.toString(t.slice(2*this.F.n8),e)} ]`}if(t.byteLength==2*this.F.n8){return`[ ${this.F.toString(t.slice(0,this.F.n8),e)}, ${this.F.toString(t.slice(this.F.n8),e)} ]`}throw new Error("invalid point size")}fromRng(t){const e=this.F;let i,n,s=[];do{s[0]=e.fromRng(t),i=t.nextBool(),n=e.add(e.mul(e.square(s[0]),s[0]),this.b)}while(!e.isSquare(n));s[1]=e.sqrt(n);i^e.isNegative(s[1])&&(s[1]=e.neg(s[1]));let r=new Uint8Array(2*this.F.n8);return r.set(s[0]),r.set(s[1],this.F.n8),this.cofactor&&(r=this.timesScalar(r,this.cofactor)),r}toObject(t){if(this.isZero(t))return[this.F.toObject(this.F.zero),this.F.toObject(this.F.one),this.F.toObject(this.F.zero)];const e=this.F.toObject(t.slice(0,this.F.n8)),i=this.F.toObject(t.slice(this.F.n8,2*this.F.n8));let n;return n=t.byteLength==3*this.F.n8?this.F.toObject(t.slice(2*this.F.n8,3*this.F.n8)):this.F.toObject(this.F.one),[e,i,n]}fromObject(t){const e=this.F.fromObject(t[0]),i=this.F.fromObject(t[1]);let n;if(n=3==t.length?this.F.fromObject(t[2]):this.F.one,this.F.isZero(n,this.F.one))return this.zeroAffine;if(this.F.eq(n,this.F.one)){const t=new Uint8Array(2*this.F.n8);return t.set(e),t.set(i,this.F.n8),t}{const t=new Uint8Array(3*this.F.n8);return t.set(e),t.set(i,this.F.n8),t.set(n,2*this.F.n8),t}}e(t){return t instanceof Uint8Array?t:this.fromObject(t)}x(t){return this.toAffine(t).slice(0,this.F.n8)}y(t){return this.toAffine(t).slice(this.F.n8)}}function ce(t){const e=32767;let i,s;async function r(t){const n=new Uint8Array(t.code),r=await WebAssembly.compile(n);s=new WebAssembly.Memory({initial:t.init,maximum:e}),i=await WebAssembly.instantiate(r,{env:{memory:s}})}function h(t){const i=new Uint32Array(s.buffer,0,1);for(;3&i[0];)i[0]++;const n=i[0];if(i[0]+=t,i[0]+t>s.buffer.byteLength){const n=s.buffer.byteLength/65536;let r=Math.floor((i[0]+t)/65536)+1;r>e&&(r=e),s.grow(r-n)}return n}function o(t){const e=h(t.byteLength);return u(e,t),e}function f(t,e){const i=new Uint8Array(s.buffer);return new Uint8Array(i.buffer,i.byteOffset+t,e)}function u(t,e){new Uint8Array(s.buffer).set(new Uint8Array(e),t)}function a(t){if("INIT"==t[0].cmd)return r(t[0]);const e={vars:[],out:[]},n=new Uint32Array(s.buffer,0,1)[0];for(let s=0;s<t.length;s++)switch(t[s].cmd){case"ALLOCSET":e.vars[t[s].var]=o(t[s].buff);break;case"ALLOC":e.vars[t[s].var]=h(t[s].len);break;case"SET":u(e.vars[t[s].var],t[s].buff);break;case"CALL":{const n=[];for(let i=0;i<t[s].params.length;i++){const r=t[s].params[i];"undefined"!==typeof r.var?n.push(e.vars[r.var]+(r.offset||0)):"undefined"!=typeof r.val&&n.push(r.val)}i.exports[t[s].fnName](...n);break}case"GET":e.out[t[s].out]=f(e.vars[t[s].var],t[s].len).slice();break;default:throw new Error("Invalid cmd")}return new Uint32Array(s.buffer,0,1)[0]=n,e.out}return t&&(t.onmessage=function(e){let i;if(i=e.data?e.data:e,"INIT"==i[0].cmd)r(i[0]).then((function(){t.postMessage(i.result)}));else if("TERMINATE"==i[0].cmd)n.exit();else{const e=a(i);t.postMessage(e)}}),a}class me{constructor(){this.promise=new Promise(((t,e)=>{this.reject=e,this.resolve=t}))}}function ge(t){for(var e=window.atob(t),i=e.length,n=new Uint8Array(i),s=0;s<i;s++)n[s]=e.charCodeAt(s);return n}var de;const Fe="data:application/javascript;base64,"+(de="("+ce.toString()+")(self)",window.btoa(de));class be{constructor(){this.actionQueue=[],this.oldPFree=0}startSyncOp(){if(0!=this.oldPFree)throw new Error("Sync operation in progress");this.oldPFree=this.u32[0]}endSyncOp(){if(0==this.oldPFree)throw new Error("No sync operation in progress");this.u32[0]=this.oldPFree,this.oldPFree=0}postAction(t,e,i,n){if(this.working[t])throw new Error("Posting a job t a working worker");return this.working[t]=!0,this.pendingDeferreds[t]=n||new me,this.workers[t].postMessage(e,i),this.pendingDeferreds[t].promise}processWorks(){for(let t=0;t<this.workers.length&&this.actionQueue.length>0;t++)if(0==this.working[t]){const e=this.actionQueue.shift();this.postAction(t,e.data,e.transfers,e.deferred)}}queueAction(t,e){const i=new me;if(this.singleThread){const e=this.taskManager(t);i.resolve(e)}else this.actionQueue.push({data:t,transfers:e,deferred:i}),this.processWorks();return i.promise}resetMemory(){this.u32[0]=this.initalPFree}allocBuff(t){const e=this.alloc(t.byteLength);return this.setBuff(e,t),e}getBuff(t,e){return this.u8.slice(t,t+e)}setBuff(t,e){this.u8.set(new Uint8Array(e),t)}alloc(t){for(;3&this.u32[0];)this.u32[0]++;const e=this.u32[0];return this.u32[0]+=t,e}async terminate(){for(let e=0;e<this.workers.length;e++)this.workers[e].postMessage([{cmd:"TERMINATE"}]);var t;await(t=200,new Promise((e=>setTimeout(e,t))))}}function we(t,e){const i=t[e],n=t.Fr,s=t.tm;t[e].batchApplyKey=async function(t,r,h,o,f){let u,a,l,p,c;if(o=o||"affine",f=f||"affine","G1"==e)"jacobian"==o?(l=3*i.F.n8,u="g1m_batchApplyKey"):(l=2*i.F.n8,u="g1m_batchApplyKeyMixed"),p=3*i.F.n8,"jacobian"==f?c=3*i.F.n8:(a="g1m_batchToAffine",c=2*i.F.n8);else if("G2"==e)"jacobian"==o?(l=3*i.F.n8,u="g2m_batchApplyKey"):(l=2*i.F.n8,u="g2m_batchApplyKeyMixed"),p=3*i.F.n8,"jacobian"==f?c=3*i.F.n8:(a="g2m_batchToAffine",c=2*i.F.n8);else{if("Fr"!=e)throw new Error("Invalid group: "+e);u="frm_batchApplyKey",l=i.n8,p=i.n8,c=i.n8}const m=Math.floor(t.byteLength/l),g=Math.floor(m/s.concurrency),d=[];h=n.e(h);let F=n.e(r);for(let e=0;e<s.concurrency;e++){let i;if(i=e<s.concurrency-1?g:m-e*g,0==i)continue;const r=[];r.push({cmd:"ALLOCSET",var:0,buff:t.slice(e*g*l,e*g*l+i*l)}),r.push({cmd:"ALLOCSET",var:1,buff:F}),r.push({cmd:"ALLOCSET",var:2,buff:h}),r.push({cmd:"ALLOC",var:3,len:i*Math.max(p,c)}),r.push({cmd:"CALL",fnName:u,params:[{var:0},{val:i},{var:1},{var:2},{var:3}]}),a&&r.push({cmd:"CALL",fnName:a,params:[{var:3},{val:i},{var:3}]}),r.push({cmd:"GET",out:0,var:3,len:i*c}),d.push(s.queueAction(r)),F=n.mul(F,n.exp(h,i))}const b=await Promise.all(d);let w;w=t instanceof oe?new oe(m*c):new Uint8Array(m*c);let y=0;for(let e=0;e<b.length;e++)w.set(b[e][0],y),y+=b[e][0].byteLength;return w}}const ye=[1,1,1,1,2,3,4,5,6,7,7,8,9,10,11,12,13,13,14,15,16,16,17,17,17,17,17,17,17,17,17,17];function Le(t,e){const i=t[e],n=i.tm;async function s(t,n,s,r,h){if(!(t instanceof Uint8Array))throw r&&r.error(`${h} _multiExpChunk buffBases is not Uint8Array`),new Error(`${h} _multiExpChunk buffBases is not Uint8Array`);if(!(n instanceof Uint8Array))throw r&&r.error(`${h} _multiExpChunk buffScalars is not Uint8Array`),new Error(`${h} _multiExpChunk buffScalars is not Uint8Array`);let o,f;if(s=s||"affine","G1"==e)"affine"==s?(f="g1m_multiexpAffine_chunk",o=2*i.F.n8):(f="g1m_multiexp_chunk",o=3*i.F.n8);else{if("G2"!=e)throw new Error("Invalid group");"affine"==s?(f="g2m_multiexpAffine_chunk",o=2*i.F.n8):(f="g2m_multiexp_chunk",o=3*i.F.n8)}const u=Math.floor(t.byteLength/o);if(0==u)return i.zero;const a=Math.floor(n.byteLength/u);if(a*u!=n.byteLength)throw new Error("Scalar size does not match");const l=ye[Kt(u)],p=Math.floor((8*a-1)/l)+1,c=[];for(let e=0;e<p;e++){const s=[{cmd:"ALLOCSET",var:0,buff:t},{cmd:"ALLOCSET",var:1,buff:n},{cmd:"ALLOC",var:2,len:3*i.F.n8},{cmd:"CALL",fnName:f,params:[{var:0},{var:1},{val:a},{val:u},{val:e*l},{val:Math.min(8*a-e*l,l)},{var:2}]},{cmd:"GET",out:0,var:2,len:3*i.F.n8}];c.push(i.tm.queueAction(s))}const m=await Promise.all(c);let g=i.zero;for(let e=m.length-1;e>=0;e--){if(!i.isZero(g))for(let t=0;t<l;t++)g=i.double(g);g=i.add(g,m[e][0])}return g}async function r(t,r,h,o,f){const u=1<<22;let a;if("G1"==e)a="affine"==h?2*i.F.n8:3*i.F.n8;else{if("G2"!=e)throw new Error("Invalid group");a="affine"==h?2*i.F.n8:3*i.F.n8}const l=Math.floor(t.byteLength/a),p=Math.floor(r.byteLength/l);if(p*l!=r.byteLength)throw new Error("Scalar size does not match");const c=ye[Kt(l)],m=Math.floor((8*p-1)/c)+1;let g;g=Math.floor(l/(n.concurrency/m)),g>u&&(g=u),g<1024&&(g=1024);const d=[];for(let e=0;e<l;e+=g){o&&o.debug(`Multiexp start: ${f}: ${e}/${l}`);const i=Math.min(l-e,g),n=t.slice(e*a,(e+i)*a),u=r.slice(e*p,(e+i)*p);d.push(s(n,u,h,o,f).then((t=>(o&&o.debug(`Multiexp end: ${f}: ${e}/${l}`),t))))}const F=await Promise.all(d);let b=i.zero;for(let e=F.length-1;e>=0;e--)b=i.add(b,F[e]);return b}i.multiExp=async function(t,e,i,n){return await r(t,e,"jacobian",i,n)},i.multiExpAffine=async function(t,e,i,n){return await r(t,e,"affine",i,n)}}function ve(t,e){const i=t[e],n=t.Fr,s=i.tm;async function r(o,f,u,a,l,p){u=u||"affine",a=a||"affine";let c,m,g,d,F,b,w,y;"G1"==e?("affine"==u?(c=2*i.F.n8,d="g1m_batchToJacobian"):c=3*i.F.n8,m=3*i.F.n8,f&&(y="g1m_fftFinal"),w="g1m_fftJoin",b="g1m_fftMix","affine"==a?(g=2*i.F.n8,F="g1m_batchToAffine"):g=3*i.F.n8):"G2"==e?("affine"==u?(c=2*i.F.n8,d="g2m_batchToJacobian"):c=3*i.F.n8,m=3*i.F.n8,f&&(y="g2m_fftFinal"),w="g2m_fftJoin",b="g2m_fftMix","affine"==a?(g=2*i.F.n8,F="g2m_batchToAffine"):g=3*i.F.n8):"Fr"==e&&(c=i.n8,m=i.n8,g=i.n8,f&&(y="frm_fftFinal"),b="frm_fftMix",w="frm_fftJoin");let L=!1;Array.isArray(o)&&(o=t.array2buffer(o,c),L=!0);const v=o.byteLength/c,B=Kt(v);if(1<<B!=v)throw new Error("fft must be multiple of 2");if(B==n.s+1){let e;return e=f?await async function(t,e,i,s,o){let f,u;f=t.slice(0,t.byteLength/2),u=t.slice(t.byteLength/2,t.byteLength);const a=[];a.push(r(f,!0,e,"jacobian",s,o)),a.push(r(u,!0,e,"jacobian",s,o)),[f,u]=await Promise.all(a);const l=await h(f,u,"fftJoinExtInv",n.one,n.shiftInv,"jacobian",i,s,o);let p;p=l[0].byteLength>1<<28?new oe(2*l[0].byteLength):new Uint8Array(2*l[0].byteLength);return p.set(l[0]),p.set(l[1],l[0].byteLength),p}(o,u,a,l,p):await async function(t,e,i,s,o){let f,u;f=t.slice(0,t.byteLength/2),u=t.slice(t.byteLength/2,t.byteLength);const a=[];[f,u]=await h(f,u,"fftJoinExt",n.one,n.shift,e,"jacobian",s,o),a.push(r(f,!1,"jacobian",i,s,o)),a.push(r(u,!1,"jacobian",i,s,o));const l=await Promise.all(a);let p;p=l[0].byteLength>1<<28?new oe(2*l[0].byteLength):new Uint8Array(2*l[0].byteLength);return p.set(l[0]),p.set(l[1],l[0].byteLength),p}(o,u,a,l,p),L?t.buffer2array(e,g):e}let E,q,O;f&&(E=n.inv(n.e(v))),Ht(o,c);let _=Math.min(16384,v),A=v/_;for(;A<s.concurrency&&_>=16;)A*=2,_/=2;const R=Kt(_),x=[];for(let t=0;t<A;t++){l&&l.debug(`${p}: fft ${B} mix start: ${t}/${A}`);const e=[];e.push({cmd:"ALLOC",var:0,len:m*_});const i=o.slice(_*t*c,_*(t+1)*c);e.push({cmd:"SET",var:0,buff:i}),d&&e.push({cmd:"CALL",fnName:d,params:[{var:0},{val:_},{var:0}]});for(let t=1;t<=R;t++)e.push({cmd:"CALL",fnName:b,params:[{var:0},{val:_},{val:t}]});R==B?(y&&(e.push({cmd:"ALLOCSET",var:1,buff:E}),e.push({cmd:"CALL",fnName:y,params:[{var:0},{val:_},{var:1}]})),F&&e.push({cmd:"CALL",fnName:F,params:[{var:0},{val:_},{var:0}]}),e.push({cmd:"GET",out:0,var:0,len:_*g})):e.push({cmd:"GET",out:0,var:0,len:m*_}),x.push(s.queueAction(e).then((e=>(l&&l.debug(`${p}: fft ${B} mix end: ${t}/${A}`),e))))}O=await Promise.all(x);for(let t=0;t<A;t++)O[t]=O[t][0];for(let t=R+1;t<=B;t++){l&&l.debug(`${p}: fft  ${B}  join: ${t}/${B}`);const e=1<<B-t,i=A/e,r=[];for(let o=0;o<e;o++)for(let h=0;h<i/2;h++){const f=n.exp(n.w[t],h*_),u=n.w[t],a=o*i+h,c=o*i+h+i/2,d=[];d.push({cmd:"ALLOCSET",var:0,buff:O[a]}),d.push({cmd:"ALLOCSET",var:1,buff:O[c]}),d.push({cmd:"ALLOCSET",var:2,buff:f}),d.push({cmd:"ALLOCSET",var:3,buff:u}),d.push({cmd:"CALL",fnName:w,params:[{var:0},{var:1},{val:_},{var:2},{var:3}]}),t==B?(y&&(d.push({cmd:"ALLOCSET",var:4,buff:E}),d.push({cmd:"CALL",fnName:y,params:[{var:0},{val:_},{var:4}]}),d.push({cmd:"CALL",fnName:y,params:[{var:1},{val:_},{var:4}]})),F&&(d.push({cmd:"CALL",fnName:F,params:[{var:0},{val:_},{var:0}]}),d.push({cmd:"CALL",fnName:F,params:[{var:1},{val:_},{var:1}]})),d.push({cmd:"GET",out:0,var:0,len:_*g}),d.push({cmd:"GET",out:1,var:1,len:_*g})):(d.push({cmd:"GET",out:0,var:0,len:_*m}),d.push({cmd:"GET",out:1,var:1,len:_*m})),r.push(s.queueAction(d).then((n=>(l&&l.debug(`${p}: fft ${B} join  ${t}/${B}  ${o+1}/${e} ${h}/${i/2}`),n))))}const h=await Promise.all(r);for(let t=0;t<e;t++)for(let e=0;e<i/2;e++){const n=t*i+e,s=t*i+e+i/2,r=h.shift();O[n]=r[0],O[s]=r[1]}}if(q=o instanceof oe?new oe(v*g):new Uint8Array(v*g),f){q.set(O[0].slice((_-1)*g));let t=g;for(let e=A-1;e>0;e--)q.set(O[e],t),t+=_*g,delete O[e];q.set(O[0].slice(0,(_-1)*g),t),delete O[0]}else for(let t=0;t<A;t++)q.set(O[t],_*g*t),delete O[t];return L?t.buffer2array(q,g):q}async function h(t,r,h,o,f,u,a,l,p){let c,m,g,d,F,b;if("G1"==e)"affine"==u?(F=2*i.F.n8,m="g1m_batchToJacobian"):F=3*i.F.n8,b=3*i.F.n8,c="g1m_"+h,"affine"==a?(g="g1m_batchToAffine",d=2*i.F.n8):d=3*i.F.n8;else if("G2"==e)"affine"==u?(F=2*i.F.n8,m="g2m_batchToJacobian"):F=3*i.F.n8,c="g2m_"+h,b=3*i.F.n8,"affine"==a?(g="g2m_batchToAffine",d=2*i.F.n8):d=3*i.F.n8;else{if("Fr"!=e)throw new Error("Invalid group");F=n.n8,d=n.n8,b=n.n8,c="frm_"+h}if(t.byteLength!=r.byteLength)throw new Error("Invalid buffer size");const w=Math.floor(t.byteLength/F);if(w!=1<<Kt(w))throw new Error("Invalid number of points");let y=Math.floor(w/s.concurrency);y<16&&(y=16),y>65536&&(y=65536);const L=[];for(let e=0;e<w;e+=y){l&&l.debug(`${p}: fftJoinExt Start: ${e}/${w}`);const i=Math.min(w-e,y),h=n.mul(o,n.exp(f,e)),u=[],a=t.slice(e*F,(e+i)*F),v=r.slice(e*F,(e+i)*F);u.push({cmd:"ALLOC",var:0,len:b*i}),u.push({cmd:"SET",var:0,buff:a}),u.push({cmd:"ALLOC",var:1,len:b*i}),u.push({cmd:"SET",var:1,buff:v}),u.push({cmd:"ALLOCSET",var:2,buff:h}),u.push({cmd:"ALLOCSET",var:3,buff:f}),m&&(u.push({cmd:"CALL",fnName:m,params:[{var:0},{val:i},{var:0}]}),u.push({cmd:"CALL",fnName:m,params:[{var:1},{val:i},{var:1}]})),u.push({cmd:"CALL",fnName:c,params:[{var:0},{var:1},{val:i},{var:2},{var:3},{val:n.s}]}),g&&(u.push({cmd:"CALL",fnName:g,params:[{var:0},{val:i},{var:0}]}),u.push({cmd:"CALL",fnName:g,params:[{var:1},{val:i},{var:1}]})),u.push({cmd:"GET",out:0,var:0,len:i*d}),u.push({cmd:"GET",out:1,var:1,len:i*d}),L.push(s.queueAction(u).then((t=>(l&&l.debug(`${p}: fftJoinExt End: ${e}/${w}`),t))))}const v=await Promise.all(L);let B,E;w*d>1<<28?(B=new oe(w*d),E=new oe(w*d)):(B=new Uint8Array(w*d),E=new Uint8Array(w*d));let q=0;for(let e=0;e<v.length;e++)B.set(v[e][0],q),E.set(v[e][1],q),q+=v[e][0].byteLength;return[B,E]}i.fft=async function(t,e,i,n,s){return await r(t,!1,e,i,n,s)},i.ifft=async function(t,e,i,n,s){return await r(t,!0,e,i,n,s)},i.lagrangeEvaluations=async function(t,s,o,f,u){let a;if(s=s||"affine",o=o||"affine","G1"==e)a="affine"==s?2*i.F.n8:3*i.F.n8;else if("G2"==e)a="affine"==s?2*i.F.n8:3*i.F.n8;else{if("Fr"!=e)throw new Error("Invalid group");a=n.n8}const l=t.byteLength/a,p=Kt(l);if(2**p*a!=t.byteLength)throw f&&f.error("lagrangeEvaluations iinvalid input size"),new Error("lagrangeEvaluations invalid Input size");if(p<=n.s)return await i.ifft(t,s,o,f,u);if(p>n.s+1)throw f&&f.error("lagrangeEvaluations input too big"),new Error("lagrangeEvaluations input too big");let c=t.slice(0,t.byteLength/2),m=t.slice(t.byteLength/2,t.byteLength);const g=n.exp(n.shift,l/2),d=n.inv(n.sub(n.one,g));[c,m]=await h(c,m,"prepareLagrangeEvaluation",d,n.shiftInv,s,"jacobian",f,u+" prep");const F=[];let b;return F.push(r(c,!0,"jacobian",o,f,u+" t0")),F.push(r(m,!0,"jacobian",o,f,u+" t1")),[c,m]=await Promise.all(F),b=c.byteLength>1<<28?new oe(2*c.byteLength):new Uint8Array(2*c.byteLength),b.set(c),b.set(m,c.byteLength),b},i.fftMix=async function(t){const r=3*i.F.n8;let h,o;if("G1"==e)h="g1m_fftMix",o="g1m_fftJoin";else if("G2"==e)h="g2m_fftMix",o="g2m_fftJoin";else{if("Fr"!=e)throw new Error("Invalid group");h="frm_fftMix",o="frm_fftJoin"}const f=Math.floor(t.byteLength/r),u=Kt(f);let a=1<<Kt(s.concurrency);f<=2*a&&(a=1);const l=f/a,p=Kt(l),c=[];for(let e=0;e<a;e++){const i=[],n=t.slice(e*l*r,(e+1)*l*r);i.push({cmd:"ALLOCSET",var:0,buff:n});for(let t=1;t<=p;t++)i.push({cmd:"CALL",fnName:h,params:[{var:0},{val:l},{val:t}]});i.push({cmd:"GET",out:0,var:0,len:l*r}),c.push(s.queueAction(i))}const m=await Promise.all(c),g=[];for(let e=0;e<m.length;e++)g[e]=m[e][0];for(let e=p+1;e<=u;e++){const t=1<<u-e,i=a/t,h=[];for(let u=0;u<t;u++)for(let t=0;t<i/2;t++){const f=n.exp(n.w[e],t*l),a=n.w[e],p=u*i+t,c=u*i+t+i/2,m=[];m.push({cmd:"ALLOCSET",var:0,buff:g[p]}),m.push({cmd:"ALLOCSET",var:1,buff:g[c]}),m.push({cmd:"ALLOCSET",var:2,buff:f}),m.push({cmd:"ALLOCSET",var:3,buff:a}),m.push({cmd:"CALL",fnName:o,params:[{var:0},{var:1},{val:l},{var:2},{var:3}]}),m.push({cmd:"GET",out:0,var:0,len:l*r}),m.push({cmd:"GET",out:1,var:1,len:l*r}),h.push(s.queueAction(m))}const f=await Promise.all(h);for(let e=0;e<t;e++)for(let t=0;t<i/2;t++){const n=e*i+t,s=e*i+t+i/2,r=f.shift();g[n]=r[0],g[s]=r[1]}}let d;d=t instanceof oe?new oe(f*r):new Uint8Array(f*r);let F=0;for(let e=0;e<a;e++)d.set(g[e],F),F+=g[e].byteLength;return d},i.fftJoin=async function(t,r,h,o){const f=3*i.F.n8;let u;if("G1"==e)u="g1m_fftJoin";else if("G2"==e)u="g2m_fftJoin";else{if("Fr"!=e)throw new Error("Invalid group");u="frm_fftJoin"}if(t.byteLength!=r.byteLength)throw new Error("Invalid buffer size");const a=Math.floor(t.byteLength/f);if(a!=1<<Kt(a))throw new Error("Invalid number of points");let l=1<<Kt(s.concurrency);a<=2*l&&(l=1);const p=a/l,c=[];for(let e=0;e<l;e++){const i=[],a=n.mul(h,n.exp(o,e*p)),l=t.slice(e*p*f,(e+1)*p*f),m=r.slice(e*p*f,(e+1)*p*f);i.push({cmd:"ALLOCSET",var:0,buff:l}),i.push({cmd:"ALLOCSET",var:1,buff:m}),i.push({cmd:"ALLOCSET",var:2,buff:a}),i.push({cmd:"ALLOCSET",var:3,buff:o}),i.push({cmd:"CALL",fnName:u,params:[{var:0},{var:1},{val:p},{var:2},{var:3}]}),i.push({cmd:"GET",out:0,var:0,len:p*f}),i.push({cmd:"GET",out:1,var:1,len:p*f}),c.push(s.queueAction(i))}const m=await Promise.all(c);let g,d;t instanceof oe?(g=new oe(a*f),d=new oe(a*f)):(g=new Uint8Array(a*f),d=new Uint8Array(a*f));let F=0;for(let e=0;e<m.length;e++)g.set(m[e][0],F),d.set(m[e][1],F),F+=m[e][0].byteLength;return[g,d]},i.fftFinal=async function(t,n){const r=3*i.F.n8,h=2*i.F.n8;let o,f;if("G1"==e)o="g1m_fftFinal",f="g1m_batchToAffine";else{if("G2"!=e)throw new Error("Invalid group");o="g2m_fftFinal",f="g2m_batchToAffine"}const u=Math.floor(t.byteLength/r);if(u!=1<<Kt(u))throw new Error("Invalid number of points");const a=Math.floor(u/s.concurrency),l=[];for(let e=0;e<s.concurrency;e++){let i;if(i=e<s.concurrency-1?a:u-e*a,0==i)continue;const p=[],c=t.slice(e*a*r,(e*a+i)*r);p.push({cmd:"ALLOCSET",var:0,buff:c}),p.push({cmd:"ALLOCSET",var:1,buff:n}),p.push({cmd:"CALL",fnName:o,params:[{var:0},{val:i},{var:1}]}),p.push({cmd:"CALL",fnName:f,params:[{var:0},{val:i},{var:0}]}),p.push({cmd:"GET",out:0,var:0,len:i*h}),l.push(s.queueAction(p))}const p=await Promise.all(l);let c;c=t instanceof oe?new oe(u*h):new Uint8Array(u*h);let m=0;for(let e=p.length-1;e>=0;e--)c.set(p[e][0],m),m+=p[e][0].byteLength;return c}}async function Be(t){const e=await async function(t,e){const i=new be;i.memory=new WebAssembly.Memory({initial:25}),i.u8=new Uint8Array(i.memory.buffer),i.u32=new Uint32Array(i.memory.buffer);const n=await WebAssembly.compile(ge(t.code));if(i.instance=await WebAssembly.instantiate(n,{env:{memory:i.memory}}),i.singleThread=e,i.initalPFree=i.u32[0],i.pq=t.pq,i.pr=t.pr,i.pG1gen=t.pG1gen,i.pG1zero=t.pG1zero,i.pG2gen=t.pG2gen,i.pG2zero=t.pG2zero,i.pOneT=t.pOneT,e)i.code=ge(t.code),i.taskManager=ce(),await i.taskManager([{cmd:"INIT",init:25,code:i.code.slice()}]),i.concurrency=1;else{let e;i.workers=[],i.pendingDeferreds=[],i.working=[],e="object"===typeof navigator&&navigator.hardwareConcurrency?navigator.hardwareConcurrency:c.default.cpus().length,e>64&&(e=64),i.concurrency=e;for(let t=0;t<e;t++)i.workers[t]=new m.default(Fe),i.workers[t].addEventListener("message",s(t)),i.working[t]=!1;const n=[];for(let s=0;s<i.workers.length;s++){const e=ge(t.code).slice();n.push(i.postAction(s,[{cmd:"INIT",init:25,code:e}],[e.buffer]))}await Promise.all(n)}return i;function s(t){return function(e){let n;n=e&&e.data?e.data:e,i.working[t]=!1,i.pendingDeferreds[t].resolve(n),i.processWorks()}}}(t.wasm,t.singleThread),i={};return i.q=Z(t.wasm.q),i.r=Z(t.wasm.r),i.name=t.name,i.tm=e,i.prePSize=t.wasm.prePSize,i.preQSize=t.wasm.preQSize,i.Fr=new ue(e,"frm",t.n8r,t.r),i.F1=new ue(e,"f1m",t.n8q,t.q),i.F2=new ae(e,"f2m",i.F1),i.G1=new pe(e,"g1m",i.F1,t.wasm.pG1gen,t.wasm.pG1b,t.cofactorG1),i.G2=new pe(e,"g2m",i.F2,t.wasm.pG2gen,t.wasm.pG2b,t.cofactorG2),i.F6=new le(e,"f6m",i.F2),i.F12=new ae(e,"ftm",i.F6),i.Gt=i.F12,we(i,"G1"),we(i,"G2"),we(i,"Fr"),Le(i,"G1"),Le(i,"G2"),ve(i,"G1"),ve(i,"G2"),ve(i,"Fr"),function(t){const e=t.tm;t.pairing=function(i,n){e.startSyncOp();const s=e.allocBuff(t.G1.toJacobian(i)),r=e.allocBuff(t.G2.toJacobian(n)),h=e.alloc(t.Gt.n8);e.instance.exports[t.name+"_pairing"](s,r,h);const o=e.getBuff(h,t.Gt.n8);return e.endSyncOp(),o},t.pairingEq=async function(){let i,n;arguments.length%2==1?(i=arguments[arguments.length-1],n=(arguments.length-1)/2):(i=t.Gt.one,n=arguments.length/2);const s=[];for(let u=0;u<n;u++){const i=[],n=t.G1.toJacobian(arguments[2*u]);i.push({cmd:"ALLOCSET",var:0,buff:n}),i.push({cmd:"ALLOC",var:1,len:t.prePSize});const r=t.G2.toJacobian(arguments[2*u+1]);i.push({cmd:"ALLOCSET",var:2,buff:r}),i.push({cmd:"ALLOC",var:3,len:t.preQSize}),i.push({cmd:"ALLOC",var:4,len:t.Gt.n8}),i.push({cmd:"CALL",fnName:t.name+"_prepareG1",params:[{var:0},{var:1}]}),i.push({cmd:"CALL",fnName:t.name+"_prepareG2",params:[{var:2},{var:3}]}),i.push({cmd:"CALL",fnName:t.name+"_millerLoop",params:[{var:1},{var:3},{var:4}]}),i.push({cmd:"GET",out:0,var:4,len:t.Gt.n8}),s.push(e.queueAction(i))}const r=await Promise.all(s);e.startSyncOp();const h=e.alloc(t.Gt.n8);e.instance.exports.ftm_one(h);for(let t=0;t<r.length;t++){const i=e.allocBuff(r[t][0]);e.instance.exports.ftm_mul(h,i,h)}e.instance.exports[t.name+"_finalExponentiation"](h,h);const o=e.allocBuff(i),f=!!e.instance.exports.ftm_eq(h,o);return e.endSyncOp(),f},t.prepareG1=function(t){this.tm.startSyncOp();const e=this.tm.allocBuff(t),i=this.tm.alloc(this.prePSize);this.tm.instance.exports[this.name+"_prepareG1"](e,i);const n=this.tm.getBuff(i,this.prePSize);return this.tm.endSyncOp(),n},t.prepareG2=function(t){this.tm.startSyncOp();const e=this.tm.allocBuff(t),i=this.tm.alloc(this.preQSize);this.tm.instance.exports[this.name+"_prepareG2"](e,i);const n=this.tm.getBuff(i,this.preQSize);return this.tm.endSyncOp(),n},t.millerLoop=function(t,e){this.tm.startSyncOp();const i=this.tm.allocBuff(t),n=this.tm.allocBuff(e),s=this.tm.alloc(this.Gt.n8);this.tm.instance.exports[this.name+"_millerLoop"](i,n,s);const r=this.tm.getBuff(s,this.Gt.n8);return this.tm.endSyncOp(),r},t.finalExponentiation=function(t){this.tm.startSyncOp();const e=this.tm.allocBuff(t),i=this.tm.alloc(this.Gt.n8);this.tm.instance.exports[this.name+"_finalExponentiation"](e,i);const n=this.tm.getBuff(i,this.Gt.n8);return this.tm.endSyncOp(),n}}(i),i.array2buffer=function(t,e){const i=new Uint8Array(e*t.length);for(let n=0;n<t.length;n++)i.set(t[n],n*e);return i},i.buffer2array=function(t,e){const i=t.byteLength/e,n=new Array(i);for(let s=0;s<i;s++)n[s]=t.slice(s*e,s*e+e);return n},i}async function Ee(t){if(!t&&i.g.curve_bn128)return i.g.curve_bn128;const e={name:"bn128",wasm:p.default.bn128_wasm,q:Z("21888242871839275222246405745257275088696311157297823662689037894645226208583"),r:Z("21888242871839275222246405745257275088548364400416034343698204186575808495617"),n8q:32,n8r:32,cofactorG2:Z("30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d",16),singleThread:!!t},n=await Be(e);return n.terminate=async function(){e.singleThread||(i.g.curve_bn128=null,await this.tm.terminate())},t||(i.g.curve_bn128=n),n}i.g.curve_bn128=null,i.g.curve_bls12381=null;const qe=Z("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),Oe=Z("21888242871839275222246405745257275088548364400416034343698204186575808495617"),_e=Z("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),Ae=Z("21888242871839275222246405745257275088696311157297823662689037894645226208583");const Re=Bt,xe=re;e.BigBuffer=oe,e.ChaCha=Ut,e.EC=class{constructor(t,e){this.F=t,this.g=e,2==this.g.length&&(this.g[2]=this.F.one),this.zero=[this.F.zero,this.F.one,this.F.zero]}add(t,e){const i=this.F;if(this.eq(t,this.zero))return e;if(this.eq(e,this.zero))return t;const n=new Array(3),s=i.square(t[2]),r=i.square(e[2]),h=i.mul(t[0],r),o=i.mul(e[0],s),f=i.mul(t[2],s),u=i.mul(e[2],r),a=i.mul(t[1],u),l=i.mul(e[1],f);if(i.eq(h,o)&&i.eq(a,l))return this.double(t);const p=i.sub(o,h),c=i.sub(l,a),m=i.square(i.add(p,p)),g=i.mul(p,m),d=i.add(c,c),F=i.mul(h,m);n[0]=i.sub(i.sub(i.square(d),g),i.add(F,F));const b=i.mul(a,g);return n[1]=i.sub(i.mul(d,i.sub(F,n[0])),i.add(b,b)),n[2]=i.mul(p,i.sub(i.square(i.add(t[2],e[2])),i.add(s,r))),n}neg(t){return[t[0],this.F.neg(t[1]),t[2]]}sub(t,e){return this.add(t,this.neg(e))}double(t){const e=this.F,i=new Array(3);if(this.eq(t,this.zero))return t;const n=e.square(t[0]),s=e.square(t[1]),r=e.square(s);let h=e.sub(e.square(e.add(t[0],s)),e.add(n,r));h=e.add(h,h);const o=e.add(e.add(n,n),n),f=e.square(o);i[0]=e.sub(f,e.add(h,h));let u=e.add(r,r);u=e.add(u,u),u=e.add(u,u),i[1]=e.sub(e.mul(o,e.sub(h,i[0])),u);const a=e.mul(t[1],t[2]);return i[2]=e.add(a,a),i}timesScalar(t,e){return Mt(this,t,e)}mulScalar(t,e){return Mt(this,t,e)}affine(t){const e=this.F;if(this.isZero(t))return this.zero;if(e.eq(t[2],e.one))return t;{const i=e.inv(t[2]),n=e.square(i),s=e.mul(n,i),r=new Array(3);return r[0]=e.mul(t[0],n),r[1]=e.mul(t[1],s),r[2]=e.one,r}}multiAffine(t){const e=Object.keys(t),i=this.F,n=new Array(e.length+1);n[0]=i.one;for(let s=0;s<e.length;s++)i.eq(t[e[s]][2],i.zero)?n[s+1]=n[s]:n[s+1]=i.mul(n[s],t[e[s]][2]);n[e.length]=i.inv(n[e.length]);for(let s=e.length-1;s>=0;s--)if(i.eq(t[e[s]][2],i.zero))n[s]=n[s+1],t[e[s]]=this.zero;else{const r=i.mul(n[s],n[s+1]);n[s]=i.mul(t[e[s]][2],n[s+1]);const h=i.square(r),o=i.mul(h,r);t[e[s]][0]=i.mul(t[e[s]][0],h),t[e[s]][1]=i.mul(t[e[s]][1],o),t[e[s]][2]=i.one}}eq(t,e){const i=this.F;if(this.F.eq(t[2],this.F.zero))return this.F.eq(e[2],this.F.zero);if(this.F.eq(e[2],this.F.zero))return!1;const n=i.square(t[2]),s=i.square(e[2]),r=i.mul(t[0],s),h=i.mul(e[0],n),o=i.mul(t[2],n),f=i.mul(e[2],s),u=i.mul(t[1],f),a=i.mul(e[1],o);return i.eq(r,h)&&i.eq(u,a)}isZero(t){return this.F.isZero(t[2])}toString(t){const e=this.affine(t);return`[ ${this.F.toString(e[0])} , ${this.F.toString(e[1])} ]`}fromRng(t){const e=this.F;let i,n=[];do{n[0]=e.fromRng(t),i=t.nextBool();const s=e.add(e.mul(e.square(n[0]),n[0]),this.b);n[1]=e.sqrt(s)}while(null==n[1]||e.isZero[n]);return i^Pt(e,n[1])&&(n[1]=e.neg(n[1])),n[2]=e.one,this.cofactor&&(n=this.mulScalar(n,this.cofactor)),n=this.affine(n),n}toRprLE(t,e,i){if(i=this.affine(i),this.isZero(i)){new Uint8Array(t,e,2*this.F.n8).fill(0)}else this.F.toRprLE(t,e,i[0]),this.F.toRprLE(t,e+this.F.n8,i[1])}toRprBE(t,e,i){if(i=this.affine(i),this.isZero(i)){new Uint8Array(t,e,2*this.F.n8).fill(0)}else this.F.toRprBE(t,e,i[0]),this.F.toRprBE(t,e+this.F.n8,i[1])}toRprLEM(t,e,i){if(i=this.affine(i),this.isZero(i)){new Uint8Array(t,e,2*this.F.n8).fill(0)}else this.F.toRprLEM(t,e,i[0]),this.F.toRprLEM(t,e+this.F.n8,i[1])}toRprLEJM(t,e,i){if(i=this.affine(i),this.isZero(i)){new Uint8Array(t,e,2*this.F.n8).fill(0)}else this.F.toRprLEM(t,e,i[0]),this.F.toRprLEM(t,e+this.F.n8,i[1]),this.F.toRprLEM(t,e+2*this.F.n8,i[2])}toRprBEM(t,e,i){if(i=this.affine(i),this.isZero(i)){new Uint8Array(t,e,2*this.F.n8).fill(0)}else this.F.toRprBEM(t,e,i[0]),this.F.toRprBEM(t,e+this.F.n8,i[1])}fromRprLE(t,e){e=e||0;const i=this.F.fromRprLE(t,e),n=this.F.fromRprLE(t,e+this.F.n8);return this.F.isZero(i)&&this.F.isZero(n)?this.zero:[i,n,this.F.one]}fromRprBE(t,e){e=e||0;const i=this.F.fromRprBE(t,e),n=this.F.fromRprBE(t,e+this.F.n8);return this.F.isZero(i)&&this.F.isZero(n)?this.zero:[i,n,this.F.one]}fromRprLEM(t,e){e=e||0;const i=this.F.fromRprLEM(t,e),n=this.F.fromRprLEM(t,e+this.F.n8);return this.F.isZero(i)&&this.F.isZero(n)?this.zero:[i,n,this.F.one]}fromRprLEJM(t,e){e=e||0;const i=this.F.fromRprLEM(t,e),n=this.F.fromRprLEM(t,e+this.F.n8),s=this.F.fromRprLEM(t,e+2*this.F.n8);return this.F.isZero(i)&&this.F.isZero(n)?this.zero:[i,n,s]}fromRprBEM(t,e){e=e||0;const i=this.F.fromRprBEM(t,e),n=this.F.fromRprBEM(t,e+this.F.n8);return this.F.isZero(i)&&this.F.isZero(n)?this.zero:[i,n,this.F.one]}fromRprCompressed(t,e){const i=this.F,n=new Uint8Array(t.buffer,e,i.n8);if(64&n[0])return this.zero;const s=new Array(3),r=0!=(128&n[0]);n[0]=127&n[0],s[0]=i.fromRprBE(t,e),r&&(n[0]=128|n[0]);const h=i.add(i.mul(i.square(s[0]),s[0]),this.b);if(s[1]=i.sqrt(h),null===s[1])throw new Error("Invalid Point!");return r^Pt(i,s[1])&&(s[1]=i.neg(s[1])),s[2]=i.one,s}toRprCompressed(t,e,i){i=this.affine(i);const n=new Uint8Array(t.buffer,e,this.F.n8);if(this.isZero(i))return n.fill(0),void(n[0]=64);this.F.toRprBE(t,e,i[0]),Pt(this.F,i[1])&&(n[0]=128|n[0])}fromRprUncompressed(t,e){return 64&t[0]?this.zero:this.fromRprBE(t,e)}toRprUncompressed(t,e,i){this.toRprBE(t,e,i),this.isZero(i)&&(t[e]=64|t[e])}},e.F1Field=$t,e.F2Field=class{constructor(t,e){this.type="F2",this.F=t,this.zero=[this.F.zero,this.F.zero],this.one=[this.F.one,this.F.zero],this.negone=this.neg(this.one),this.nonResidue=e,this.m=2*t.m,this.p=t.p,this.n64=2*t.n64,this.n32=2*this.n64,this.n8=8*this.n64,St(this)}_mulByNonResidue(t){return this.F.mul(this.nonResidue,t)}copy(t){return[this.F.copy(t[0]),this.F.copy(t[1])]}add(t,e){return[this.F.add(t[0],e[0]),this.F.add(t[1],e[1])]}double(t){return this.add(t,t)}sub(t,e){return[this.F.sub(t[0],e[0]),this.F.sub(t[1],e[1])]}neg(t){return this.sub(this.zero,t)}conjugate(t){return[t[0],this.F.neg(t[1])]}mul(t,e){const i=this.F.mul(t[0],e[0]),n=this.F.mul(t[1],e[1]);return[this.F.add(i,this._mulByNonResidue(n)),this.F.sub(this.F.mul(this.F.add(t[0],t[1]),this.F.add(e[0],e[1])),this.F.add(i,n))]}inv(t){const e=this.F.square(t[0]),i=this.F.square(t[1]),n=this.F.sub(e,this._mulByNonResidue(i)),s=this.F.inv(n);return[this.F.mul(t[0],s),this.F.neg(this.F.mul(t[1],s))]}div(t,e){return this.mul(t,this.inv(e))}square(t){const e=this.F.mul(t[0],t[1]);return[this.F.sub(this.F.mul(this.F.add(t[0],t[1]),this.F.add(t[0],this._mulByNonResidue(t[1]))),this.F.add(e,this._mulByNonResidue(e))),this.F.add(e,e)]}isZero(t){return this.F.isZero(t[0])&&this.F.isZero(t[1])}eq(t,e){return this.F.eq(t[0],e[0])&&this.F.eq(t[1],e[1])}mulScalar(t,e){return Mt(this,t,e)}pow(t,e){return zt(this,t,e)}exp(t,e){return zt(this,t,e)}toString(t){return`[ ${this.F.toString(t[0])} , ${this.F.toString(t[1])} ]`}fromRng(t){return[this.F.fromRng(t),this.F.fromRng(t)]}gt(t,e){return!!this.F.gt(t[0],e[0])||!this.F.gt(e[0],t[0])&&!!this.F.gt(t[1],e[1])}geq(t,e){return this.gt(t,e)||this.eq(t,e)}lt(t,e){return!this.geq(t,e)}leq(t,e){return!this.gt(t,e)}neq(t,e){return!this.eq(t,e)}random(){return[this.F.random(),this.F.random()]}toRprLE(t,e,i){this.F.toRprLE(t,e,i[0]),this.F.toRprLE(t,e+this.F.n8,i[1])}toRprBE(t,e,i){this.F.toRprBE(t,e,i[1]),this.F.toRprBE(t,e+this.F.n8,i[0])}toRprLEM(t,e,i){this.F.toRprLEM(t,e,i[0]),this.F.toRprLEM(t,e+this.F.n8,i[1])}toRprBEM(t,e,i){this.F.toRprBEM(t,e,i[1]),this.F.toRprBEM(t,e+this.F.n8,i[0])}fromRprLE(t,e){e=e||0;return[this.F.fromRprLE(t,e),this.F.fromRprLE(t,e+this.F.n8)]}fromRprBE(t,e){e=e||0;const i=this.F.fromRprBE(t,e);return[this.F.fromRprBE(t,e+this.F.n8),i]}fromRprLEM(t,e){e=e||0;return[this.F.fromRprLEM(t,e),this.F.fromRprLEM(t,e+this.F.n8)]}fromRprBEM(t,e){e=e||0;const i=this.F.fromRprBEM(t,e);return[this.F.fromRprBEM(t,e+this.F.n8),i]}},e.F3Field=class{constructor(t,e){this.type="F3",this.F=t,this.zero=[this.F.zero,this.F.zero,this.F.zero],this.one=[this.F.one,this.F.zero,this.F.zero],this.negone=this.neg(this.one),this.nonResidue=e,this.m=3*t.m,this.p=t.p,this.n64=3*t.n64,this.n32=2*this.n64,this.n8=8*this.n64}_mulByNonResidue(t){return this.F.mul(this.nonResidue,t)}copy(t){return[this.F.copy(t[0]),this.F.copy(t[1]),this.F.copy(t[2])]}add(t,e){return[this.F.add(t[0],e[0]),this.F.add(t[1],e[1]),this.F.add(t[2],e[2])]}double(t){return this.add(t,t)}sub(t,e){return[this.F.sub(t[0],e[0]),this.F.sub(t[1],e[1]),this.F.sub(t[2],e[2])]}neg(t){return this.sub(this.zero,t)}mul(t,e){const i=this.F.mul(t[0],e[0]),n=this.F.mul(t[1],e[1]),s=this.F.mul(t[2],e[2]);return[this.F.add(i,this._mulByNonResidue(this.F.sub(this.F.mul(this.F.add(t[1],t[2]),this.F.add(e[1],e[2])),this.F.add(n,s)))),this.F.add(this.F.sub(this.F.mul(this.F.add(t[0],t[1]),this.F.add(e[0],e[1])),this.F.add(i,n)),this._mulByNonResidue(s)),this.F.add(this.F.sub(this.F.mul(this.F.add(t[0],t[2]),this.F.add(e[0],e[2])),this.F.add(i,s)),n)]}inv(t){const e=this.F.square(t[0]),i=this.F.square(t[1]),n=this.F.square(t[2]),s=this.F.mul(t[0],t[1]),r=this.F.mul(t[0],t[2]),h=this.F.mul(t[1],t[2]),o=this.F.sub(e,this._mulByNonResidue(h)),f=this.F.sub(this._mulByNonResidue(n),s),u=this.F.sub(i,r),a=this.F.inv(this.F.add(this.F.mul(t[0],o),this._mulByNonResidue(this.F.add(this.F.mul(t[2],f),this.F.mul(t[1],u)))));return[this.F.mul(a,o),this.F.mul(a,f),this.F.mul(a,u)]}div(t,e){return this.mul(t,this.inv(e))}square(t){const e=this.F.square(t[0]),i=this.F.mul(t[0],t[1]),n=this.F.add(i,i),s=this.F.square(this.F.add(this.F.sub(t[0],t[1]),t[2])),r=this.F.mul(t[1],t[2]),h=this.F.add(r,r),o=this.F.square(t[2]);return[this.F.add(e,this._mulByNonResidue(h)),this.F.add(n,this._mulByNonResidue(o)),this.F.sub(this.F.add(this.F.add(n,s),h),this.F.add(e,o))]}isZero(t){return this.F.isZero(t[0])&&this.F.isZero(t[1])&&this.F.isZero(t[2])}eq(t,e){return this.F.eq(t[0],e[0])&&this.F.eq(t[1],e[1])&&this.F.eq(t[2],e[2])}affine(t){return[this.F.affine(t[0]),this.F.affine(t[1]),this.F.affine(t[2])]}mulScalar(t,e){return Mt(this,t,e)}pow(t,e){return zt(this,t,e)}exp(t,e){return zt(this,t,e)}toString(t){return`[ ${this.F.toString(t[0])} , ${this.F.toString(t[1])}, ${this.F.toString(t[2])} ]`}fromRng(t){return[this.F.fromRng(t),this.F.fromRng(t),this.F.fromRng(t)]}gt(t,e){return!!this.F.gt(t[0],e[0])||!this.F.gt(e[0],t[0])&&(!!this.F.gt(t[1],e[1])||!this.F.gt(e[1],t[1])&&!!this.F.gt(t[2],e[2]))}geq(t,e){return this.gt(t,e)||this.eq(t,e)}lt(t,e){return!this.geq(t,e)}leq(t,e){return!this.gt(t,e)}neq(t,e){return!this.eq(t,e)}random(){return[this.F.random(),this.F.random(),this.F.random()]}toRprLE(t,e,i){this.F.toRprLE(t,e,i[0]),this.F.toRprLE(t,e+this.F.n8,i[1]),this.F.toRprLE(t,e+2*this.F.n8,i[2])}toRprBE(t,e,i){this.F.toRprBE(t,e,i[2]),this.F.toRprBE(t,e+this.F.n8,i[1]),this.F.toRprBE(t,e+2*this.F.n8,i[0])}toRprLEM(t,e,i){this.F.toRprLEM(t,e,i[0]),this.F.toRprLEM(t,e+this.F.n8,i[1]),this.F.toRprLEM(t,e+2*this.F.n8,i[2])}toRprBEM(t,e,i){this.F.toRprBEM(t,e,i[2]),this.F.toRprBEM(t,e+this.F.n8,i[1]),this.F.toRprBEM(t,e+2*this.F.n8,i[0])}fromRprLE(t,e){e=e||0;return[this.F.fromRprLE(t,e),this.F.fromRprLE(t,e+this.n8),this.F.fromRprLE(t,e+2*this.n8)]}fromRprBE(t,e){e=e||0;const i=this.F.fromRprBE(t,e),n=this.F.fromRprBE(t,e+this.n8);return[this.F.fromRprBE(t,e+2*this.n8),n,i]}fromRprLEM(t,e){e=e||0;return[this.F.fromRprLEM(t,e),this.F.fromRprLEM(t,e+this.n8),this.F.fromRprLEM(t,e+2*this.n8)]}fromRprBEM(t,e){e=e||0;const i=this.F.fromRprBEM(t,e),n=this.F.fromRprBEM(t,e+this.n8);return[this.F.fromRprBEM(t,e+2*this.n8),n,i]}},e.PolField=class{constructor(t){this.F=t;let e=t.sqrt_t,i=t.sqrt_s;const n=this.F.add(this.F.add(this.F.two,this.F.two),this.F.one);this.w=new Array(i+1),this.wi=new Array(i+1),this.w[i]=this.F.pow(n,e),this.wi[i]=this.F.inv(this.w[i]);let s=i-1;for(;s>=0;)this.w[s]=this.F.square(this.w[s+1]),this.wi[s]=this.F.square(this.wi[s+1]),s--;this.roots=[],this._setRoots(15)}_setRoots(t){t>this.F.sqrt_s&&(t=this.s);for(let e=t;e>=0&&!this.roots[e];e--){let t=this.F.one;const i=1<<e,n=new Array(i);for(let s=0;s<i;s++)n[s]=t,t=this.F.mul(t,this.w[e]);this.roots[e]=n}}add(t,e){const i=Math.max(t.length,e.length),n=new Array(i);for(let s=0;s<i;s++)n[s]=this.F.add(t[s]||this.F.zero,e[s]||this.F.zero);return this.reduce(n)}double(t){return this.add(t,t)}sub(t,e){const i=Math.max(t.length,e.length),n=new Array(i);for(let s=0;s<i;s++)n[s]=this.F.sub(t[s]||this.F.zero,e[s]||this.F.zero);return this.reduce(n)}mulScalar(t,e){if(this.F.eq(e,this.F.zero))return[];if(this.F.eq(e,this.F.one))return t;const i=new Array(t.length);for(let n=0;n<t.length;n++)i[n]=this.F.mul(t[n],e);return i}mul(t,e){return 0==t.length||0==e.length?[]:1==t.length?this.mulScalar(e,t[0]):1==e.length?this.mulScalar(t,e[0]):(e.length>t.length&&([e,t]=[t,e]),e.length<=2||e.length<Et(t.length)?this.mulNormal(t,e):this.mulFFT(t,e))}mulNormal(t,e){let i=[];for(let n=0;n<e.length;n++)i=this.add(i,this.scaleX(this.mulScalar(t,e[n]),n));return i}mulFFT(t,e){const i=Et(Math.max(t.length,e.length)-1)+2;this._setRoots(i);const n=1<<i,s=this.extend(t,n),r=this.extend(e,n),h=qt(this,s,i,0,1),o=qt(this,r,i,0,1),f=new Array(n);for(let p=0;p<n;p++)f[p]=this.F.mul(h[p],o[p]);const u=qt(this,f,i,0,1),a=this.F.inv(this.F.mulScalar(this.F.one,n)),l=new Array(n);for(let p=0;p<n;p++)l[p]=this.F.mul(u[(n-p)%n],a);return this.reduce(l)}square(t){return this.mul(t,t)}scaleX(t,e){if(0==e)return t;if(e>0){return new Array(e).fill(this.F.zero).concat(t)}return-e>=t.length?[]:t.slice(-e)}eval2(t,e){let i=this.F.zero,n=this.F.one;for(let s=0;s<t.length;s++)i=this.F.add(i,this.F.mul(t[s],n)),n=this.F.mul(n,e);return i}eval(t,e){const i=this.F;if(0==t.length)return i.zero;const n=this._next2Power(t.length);return function t(e,n,s,r,h){if(1==h)return e[s];const o=i.square(n),f=i.add(t(e,o,s,r<<1,h>>1),i.mul(n,t(e,o,s+r,r<<1,h>>1)));return f}(this.extend(t,n),e,0,1,n)}lagrange(t){let e=[this.F.one];for(let n=0;n<t.length;n++)e=this.mul(e,[this.F.neg(t[n][0]),this.F.one]);let i=[];for(let n=0;n<t.length;n++){let s=this.ruffini(e,t[n][0]);const r=this.F.mul(this.F.inv(this.eval(s,t[n][0])),t[n][1]);s=this.mulScalar(s,r),i=this.add(i,s)}return i}fft(t){if(t.length<=1)return t;const e=Et(t.length-1)+1;this._setRoots(e);const i=1<<e;return qt(this,this.extend(t,i),e,0,1)}fft2(t){if(t.length<=1)return t;const e=Et(t.length-1)+1;this._setRoots(e);const i=1<<e,n=this.extend(t,i);xt(n,e);return Ot(this,n,e)}ifft(t){if(t.length<=1)return t;const e=Et(t.length-1)+1;this._setRoots(e);const i=1<<e,n=qt(this,this.extend(t,i),e,0,1),s=this.F.inv(this.F.mulScalar(this.F.one,i)),r=new Array(i);for(let h=0;h<i;h++)r[h]=this.F.mul(n[(i-h)%i],s);return r}ifft2(t){if(t.length<=1)return t;const e=Et(t.length-1)+1;this._setRoots(e);const i=1<<e,n=this.extend(t,i);xt(n,e);const s=Ot(this,n,e),r=this.F.inv(this.F.mulScalar(this.F.one,i)),h=new Array(i);for(let o=0;o<i;o++)h[o]=this.F.mul(s[(i-o)%i],r);return h}_fft(t,e,i,n){const s=1<<e;if(1==s)return[t[i]];const r=s>>1,h=this._fft(t,e-1,i,2*n),o=this._fft(t,e-1,i+n,2*n),f=new Array(s);let u=this.F.one;for(let a=0;a<r;a++)f[a]=this.F.add(h[a],this.F.mul(u,o[a])),f[a+r]=this.F.sub(h[a],this.F.mul(u,o[a])),u=this.F.mul(u,this.w[e]);return f}extend(t,e){if(e==t.length)return t;const i=new Array(e-t.length).fill(this.F.zero);return t.concat(i)}reduce(t){if(0==t.length)return t;if(!this.F.eq(t[t.length-1],this.F.zero))return t;let e=t.length-1;for(;e>0&&this.F.eq(t[e],this.F.zero);)e--;return t.slice(0,e+1)}eq(t,e){const i=this.reduce(t),n=this.reduce(e);if(i.length!=n.length)return!1;for(let s=0;s<n.length;s++)if(!this.F.eq(i[s],n[s]))return!1;return!0}ruffini(t,e){const i=new Array(t.length-1);i[i.length-1]=t[t.length-1];for(let n=i.length-2;n>=0;n--)i[n]=this.F.add(this.F.mul(i[n+1],e),t[n+1]);return i}_next2Power(t){return t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t}toString(t){let e="";for(let i=this.normalize(t).length-1;i>=0;i--)this.F.eq(t[i],this.F.zero)||(""!=e&&(e+=" + "),e+=t[i].toString(10),i>0&&(e+="x",i>1&&(e=e+"^"+i)));return e}normalize(t){const e=new Array(t.length);for(let i=0;i<t.length;i++)e[i]=this.F.normalize(t[i]);return e}_reciprocal(t,e){const i=1<<e;if(1==i)return[this.F.inv(t[0])];const n=this.scaleX(t,-i/2),s=this._reciprocal(n,e-1),r=this.scaleX(this.double(s),3*i/2-2),h=this.mul(this.square(s),t);return this.scaleX(this.sub(r,h),-(i-2))}_div2(t,e){const i=Et(e.length-1)+1,n=1<<i,s=n-e.length,r=this._reciprocal(this.scaleX(e,s),i);return this.scaleX(r,t-2*n+2+s)}div(t,e){if(t.length<e.length)return[];const i=Et(e.length-1)+1,n=1<<i,s=this.scaleX(t,n-e.length),r=this.scaleX(e,n-e.length),h=r.length-1;let o=s.length-1;const f=this._reciprocal(r,i);let u;o>2*h&&(u=this.sub(this.scaleX([this.F.one],2*h),this.mul(f,r)));let a,l,p=[],c=s,m=!1;for(;!m;)a=this.mul(c,f),p=this.add(p,this.scaleX(a,-2*h)),o>2*h?(l=this.mul(c,u),c=this.scaleX(l,-2*h),o=c.length-1):m=!0;return p}oneRoot(t,e){let i=Et(t-1)+1,n=this.F.one,s=e;if(e>=t)throw new Error("Given 'i' should be lower than 'n'");if(1<<i!==t)throw new Error(`Internal errlr: ${t} should equal ${1<<i}`);for(;s>0;)!0&s&&(n=this.F.mul(n,this.w[i])),s>>=1,i--;return n}computeVanishingPolinomial(t,e){const i=1<<t;return this.F.sub(this.F.pow(e,i),this.F.one)}evaluateLagrangePolynomials(t,e){const i=1<<t,n=this.F.pow(e,i),s=new Array(i).fill(this.F.zero);this._setRoots(t);const r=this.w[t];if(this.F.eq(n,this.F.one))for(let f=0;f<i;f++)if(this.F.eq(this.roots[t][0],e))return s[f]=this.F.one,s;const h=this.F.sub(n,this.F.one);let o=this.F.mul(h,this.F.inv(this.F.e(i)));for(let f=0;f<i;f++)s[f]=this.F.mul(o,this.F.inv(this.F.sub(e,this.roots[t][f]))),o=this.F.mul(o,r);return s}log2(t){return Et(t)}},e.Scalar=Re,e.ZqField=$t,e.buildBls12381=async function(t){if(!t&&i.g.curve_bls12381)return i.g.curve_bls12381;const e={name:"bls12381",wasm:p.default.bls12381_wasm,q:Z("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),r:Z("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),n8q:48,n8r:32,cofactorG1:Z("0x396c8c005555e1568c00aaab0000aaab",16),cofactorG2:Z("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5",16),singleThread:!!t},n=await Be(e);return n.terminate=async function(){e.singleThread||(i.g.curve_bls12381=null,await this.tm.terminate())},n},e.buildBn128=Ee,e.getCurveFromName=async function(t,e){let i;const n=t.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(n)>=0)i=await Ee(e);else{if(!(["BLS12381"].indexOf(n)>=0))throw new Error(`Curve not supported: ${t}`);i=await Ee(e)}return i},e.getCurveFromQ=async function(t,e){let i;if(lt(t,Ae))i=await Ee(e);else{if(!lt(t,_e))throw new Error(`Curve not supported: ${N(t)}`);i=await Ee(e)}return i},e.getCurveFromR=async function(t,e){let i;if(lt(t,Oe))i=await Ee(e);else{if(!lt(t,qe))throw new Error(`Curve not supported: ${N(t)}`);i=await Ee(e)}return i},e.utils=xe}}]);